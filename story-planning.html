<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Timelines</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Reuse your existing styles; this file only provides structure. -->
  <link rel="stylesheet" href="story-styles.css" />
</head>

<body data-theme="light">
  <header class="app-header">
    <div class="left">
      <h1 class="app-title">Timelines</h1>
    </div>
    <div class="right controls">
      <button id="btn-theme" class="btn">Toggle Theme</button>
      <button id="btn-edit" class="btn primary">Edit</button>
      <!-- Import/Download moved into the editor header -->
    </div>
  </header>

  <main class="app-main">
    <!-- Editor (hidden by default) -->
    <aside id="editor" class="panel editor hidden" aria-hidden="true">
      <div class="editor-header">
        <h2>Editor</h2>
        <div class="row gap">
          <label class="btn">
            Import .js
            <input id="file-import-editor" type="file" accept=".js" hidden />
          </label>
          <button id="btn-download-editor" class="btn">Download .js</button>
          <button id="btn-exit-edit" class="btn">Done</button>
        </div>
      </div>

      <div class="editor-body">
        <section>
          <div class="timeline-editor-head">
            <h3>Timelines</h3>
            <div class="row gap">
              <button id="btn-add-timeline" class="btn">+ Add Timeline</button>
              <button id="btn-dup-timeline" class="btn">Duplicate</button>
            </div>
          </div>
          <div id="timeline-list" class="listbox" role="listbox" aria-label="Timelines"></div>

          <div class="timeline-editor-head" style="margin-top:1rem;">
            <h3>Story Timelines</h3>
            <div class="row gap">
              <button id="btn-add-story-timeline" class="btn">+ Add Story Timeline</button>
              <button id="btn-dup-story-timeline" class="btn">Duplicate</button>
            </div>
          </div>
          <div id="story-timeline-list" class="listbox" role="listbox" aria-label="Story Timelines"></div>
        </section>

        <section id="timeline-editor" class="stack gap">
          <!-- Normal timeline editor -->
          <div id="timeline-editor-normal" class="stack gap">
            <div class="timeline-editor-head">
              <h3>Timeline Details</h3>
              <div class="row gap">
                <button id="btn-add-event" class="btn">+ Add Event</button>
                <button id="btn-del-timeline" class="btn danger">Delete Timeline</button>
              </div>
            </div>
            <div class="timeline-editor-body">
              <div class="column between">
                <div>
                  <label>Title
                    <input id="tl-title" type="text" placeholder="Timeline title" />
                  </label>

                  <label>Anchor Year
                    <input id="tl-year" type="text" step="1" placeholder="2000 | 5aKANTO" />
                  </label>

                  <label>Color (optional)
                    <input id="tl-color" type="color" />
                  </label>
                </div>
                <div>
                  <label style="flex:1 1 100%;">Timeline Description
                    <textarea id="tl-desc" rows="3"
                      placeholder="Shown on the anchor event (Markdown supported)"></textarea>
                  </label>

                  <label style="flex:1 1 100%;">Timeline Image (slug/subpath/url)
                    <input id="tl-image" type="text" placeholder="slug.webp | folder/slug.webp | https://â€¦" />
                  </label>
                </div>

                <button id="btn-sort-events" class="btn">Sort</button>
              </div>

              <table class="events-table">
                <thead>
                  <tr>
                    <th style="width:10rem">Year</th>
                    <th style="width:16rem">Title</th>
                    <th>Description</th>
                    <th style="width:5rem"></th>
                  </tr>
                </thead>
                <tbody id="events-body"></tbody>
              </table>
              <div class="muted small">Year accepts <code>####</code> or <code>####bc</code> (e.g., <code>1994</code>,
                <code>3000000bc</code>).
              </div>
            </div>
          </div>

          <!-- Story timeline editor -->
          <div id="timeline-editor-story" class="stack gap hidden" aria-hidden="true">
            <div class="timeline-editor-head">
              <h3>Story Timeline Details</h3>
              <div class="row gap">
                <button id="btn-add-sequence" class="btn">+ Add Sequence</button>
                <button id="btn-del-story-timeline" class="btn danger">Delete Story Timeline</button>
              </div>
            </div>

            <div class="timeline-editor-body">
              <div class="column between">
                <div>
                  <label>Title
                    <input id="st-title" type="text" placeholder="Story timeline title" />
                  </label>
                </div>
              </div>

              <table class="events-table">
                <thead>
                  <tr>
                    <th style="width:26rem">Sequence</th>
                    <th style="width:22rem">Map</th>
                    <th style="width:5rem"></th>
                  </tr>
                </thead>
                <tbody id="sequences-body"></tbody>
              </table>
              <div class="muted small">
                Map accepts multiple page blocks. Example:<br>
                <code>01</code><br>
                <code>- Kalos 0ya.01</code><br>
                <code>- Kalos 0ya.02 Flashback</code>
              </div>
            </div>
          </div>
        </section>
      </div>
    </aside>

    <!-- Timeline Grid -->
    <section class="viewport">
      <div id="grid" class="year-grid" role="grid" aria-label="Year timelines grid"></div>
    </section>
  </main>

  <!-- Your data file as a classic script (global) -->
  <script src="./story-timelines.js"></script>

  <!-- Main logic -->
  <script type="module">
    const DATA_DEFAULT = window.TIMELINES_DEFAULT;

    /***************
     * Data Model  *
     ***************/
    /**
     * Data shape:
     * window.TIMELINES_DEFAULT = {
     *   timelines: [
     *     { id, title, color?, events: [{year:"1994"| "3000000bc", title?, desc?, image?, category?}] }
     *   ]
     * }
     */
    const state = {
      timelines: [],
      editMode: false,
      selectedTimelineId: null,
      selectedStoryTimelineId: null,
      selectedEditorKind: "timeline",
      theme: 'light',
      hiddenTimelineIds: new Set(),
      showDescriptions: false,
      showImages: true,
      storyTimelines: [],
      hiddenStoryTimelineIds: new Set(),
    };

    function moveTimeline(fromIndex, toIndex) {
      if (fromIndex === toIndex) return;
      if (fromIndex < 0 || toIndex < 0) return;
      if (fromIndex >= state.timelines.length || toIndex >= state.timelines.length) return;

      const [item] = state.timelines.splice(fromIndex, 1);
      state.timelines.splice(toIndex, 0, item);
    }

    function indexOfTimelineId(id) {
      return state.timelines.findIndex(t => t.id === id);
    }

    function normalizeTimelineKey(name) {
      return String(name || '').trim().toLowerCase();
    }

    function getTimelineByName(name, timelines) {
      const key = normalizeTimelineKey(name);
      return (timelines || []).find(t => normalizeTimelineKey(t.title) === key) || null;
    }

    /**
     * Resolve a timeline's anchor year to an absolute numeric year.
     * Supports:
     *  - 1999
     *  - "1999"
     *  - "5aKANTO" (relative to another timeline anchor)
     */
    function resolveTimelineAnchorYear(tl, ctx) {
      const timelines = ctx?.timelines || (typeof state !== 'undefined' ? state.timelines : []) || [];
      const cache = ctx?.cache || null;
      const stack = ctx?.stack || [];

      if (!tl) return 2000;

      if (cache && cache.has(tl.id)) return cache.get(tl.id);

      // Cycle protection
      if (stack.includes(tl.id)) {
        throw new Error(`Circular anchor reference detected: ${stack.join(' -> ')} -> ${tl.id}`);
      }
      stack.push(tl.id);

      const raw = tl.year;

      let out;
      if (typeof raw === 'number' && Number.isFinite(raw)) {
        out = raw;
      } else if (typeof raw === 'string' && raw.trim() !== '') {
        // Note: baseYear is irrelevant for absolute years,
        // but parseYearToken also handles "ya" if someone ever uses it in anchor years.
        out = parseYearToken(raw, 2000, { timelines, cache, stack }).year;
      } else {
        out = 2000;
      }

      stack.pop();
      if (cache) cache.set(tl.id, out);
      return out;
    }

    function normalizeStoryTimelines(arr) {
      const out = Array.isArray(arr) ? arr : [];
      for (const st of out) {
        st.id ||= 'st_' + Math.random().toString(36).slice(2, 8);
        st.title ||= '(Untitled Story Timeline)';
        st.sequences = Array.isArray(st.sequences) ? st.sequences : [];

        for (const seq of st.sequences) {
          seq.seq ||= 0; // numeric sort key
          seq.title = String(seq.title || ''); // keep if you still want a title for the sequence itself
          // seq.desc is now deprecated/ignored (kept only for backwards compatibility if it exists)
          seq.map = String(seq.map || '');
        }
      }
      return out;
    }

    /**
     * Parse the mapping text from a sequence.
     * Supported line formats (leading/trailing whitespace ok):
     *  - "01"
     *  - "- Kalos 0ya.02 Flashback"
     *  - "- Kalos 1964.03"
     *
     * Output:
     *  { page: "01", refs: [{ timelineName, token, category }] }
     */
    function parseSequenceMapBlocks(mapText) {
      const lines = String(mapText || '').replace(/\r\n/g, '\n').split('\n');

      /**
       * Output blocks:
       * {
       *   scene: "01",
       *   sceneTitle: "Optional title",
       *   refs: [{ timelineName, token, category, pageCount }]
       * }
       */
      const blocks = [];
      let current = null;

      const pushCurrent = () => {
        if (!current) return;
        if (current.scene && current.refs.length) blocks.push(current);
        current = null;
      };

      for (const rawLine of lines) {
        const line = rawLine.trim();
        if (!line) continue;

        // Scene header: "01" or "01: Title"
        {
          const m = line.match(/^(\d+)\s*(?::\s*(.+))?$/);
          if (m) {
            pushCurrent();
            const scene = String(m[1] || '').padStart(2, '0');
            const sceneTitle = String(m[2] || '').trim();
            current = { scene, sceneTitle, refs: [] };
            continue;
          }
        }

        // Ref line:
        // "- Kalos 0ya.01"
        // "- Kalos 0ya.01 Flashback"
        // "- Kalos 0ya.01 Flashback (3)"
        // "- Kalos 0ya.01 (3)"
        const m = line.match(/^-+\s*(.+?)\s+([^\s]+)\s*(.*)$/);
        if (!m) continue;
        if (!current) continue;

        const timelineName = (m[1] || '').trim();
        const token = (m[2] || '').trim();
        let rest = (m[3] || '').trim();

        if (!timelineName || !token) continue;

        // Pull "(N)" from the end if present
        let pageCount = 1;
        const pm = rest.match(/\((\d+)\)\s*$/);
        if (pm) {
          pageCount = parseInt(pm[1], 10);
          if (!Number.isFinite(pageCount) || pageCount < 1) pageCount = 1;
          rest = rest.replace(/\((\d+)\)\s*$/, '').trim();
        }

        const category = rest; // whatever remains is still treated as category text

        current.refs.push({ timelineName, token, category, pageCount });
      }

      pushCurrent();
      return blocks;
    }

    /**
     * Resolve a story ref ("Kalos 0ya.02") into:
     *  { absYear, tick, timelineId? }
     */
    function resolveStoryRef(ref, ctx) {
      const timelines = ctx?.timelines || state.timelines || [];
      const tl = getTimelineByName(ref.timelineName, timelines);
      if (!tl) throw new Error(`Story ref timeline not found: "${ref.timelineName}"`);

      const anchorYear = resolveTimelineAnchorYear(tl, ctx);
      const { base, tick } = splitBaseAndTick(ref.token);
      const absYear = parseYearToken(base, anchorYear, ctx).year;

      return { absYear, tick: tick || 0, timelineId: tl.id };
    }

    function renderStoryPageBlock(page, yearTickCount, storyId, absYear) {
      const el = document.createElement('div');
      el.className = 'story-page';

      el.dataset.storyId = storyId;
      el.dataset.seq = String(parseInt(page.seqNum || '0', 10) || 0);
      el.dataset.scene = String(parseInt(page.sceneNum || '0', 10) || 0);
      el.dataset.absYear = String(absYear | 0);

      el.style.setProperty('--fromTick', String(page.fromTick || 1));
      el.style.setProperty('--toTick', String(page.toTick || 1));
      el.style.setProperty('--yearTickCount', String(Math.max(0, yearTickCount | 0)));

      if (Number.isFinite(page.fromTick) && Number.isFinite(page.toTick)) {
        el.style.gridColumn = `${page.fromTick} / ${page.toTick + 1}`;
      }

      // Head
      const head = document.createElement('div');
      head.className = 'story-page-head';

      // Nav buttons (shown on hover via CSS)
      const btnPrev = document.createElement('button');
      btnPrev.type = 'button';
      btnPrev.className = 'story-head-nav story-head-nav-prev';
      btnPrev.setAttribute('aria-label', 'Previous story tick');
      btnPrev.textContent = 'ðŸ œ';
      btnPrev.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        gotoAdjacentStoryTickGroup(storyId, -1, el);
      };

      const btnNext = document.createElement('button');
      btnNext.type = 'button';
      btnNext.className = 'story-head-nav story-head-nav-next';
      btnNext.setAttribute('aria-label', 'Next story tick');
      btnNext.textContent = 'ðŸ ž';
      btnNext.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        gotoAdjacentStoryTickGroup(storyId, +1, el);
      };

      // Head text
      const headText = document.createElement('span');
      headText.className = 'story-head-text';
      headText.textContent = page.headText || '';

      head.appendChild(headText);
      head.appendChild(btnPrev);
      head.appendChild(btnNext);

      // Page count span
      const totalPages = Number.isFinite(+page.totalPages) ? (+page.totalPages | 0) : 0;
      if (totalPages > 0) {
        const count = document.createElement('span');
        count.className = 'story-page-count';
        count.textContent = `(${totalPages} pages)`;
        head.appendChild(count);
      }

      el.appendChild(head);

      // Hover tooltip remains on the page block
      if (page.hoverText) {
        el.addEventListener('pointerenter', (e) => {
          showDescTooltip(`<div class="chip-desc">${escapeHtml(page.hoverText)}</div>`, e.clientX, e.clientY);
        });
        el.addEventListener('pointermove', (e) => {
          showDescTooltip(`<div class="chip-desc">${escapeHtml(page.hoverText)}</div>`, e.clientX, e.clientY);
        });
        el.addEventListener('pointerleave', hideDescTooltip);
      }

      // Ticks rail
      const fromTick = Math.max(1, page.fromTick | 0);
      const toTick = Math.max(fromTick, page.toTick | 0);
      const spanCount = (toTick - fromTick + 1) | 0;

      const onSet = new Set((page.onTicks || []).map(n => n | 0).filter(n => n > 0));
      const pagesByTick = page.pagesByTick instanceof Map ? page.pagesByTick : new Map();

      const rail = document.createElement('div');
      rail.className = 'story-ticks';
      rail.dataset.storyId = storyId;
      rail.dataset.seq = String(parseInt(page.seqNum || '0', 10) || 0);
      rail.dataset.scene = String(parseInt(page.sceneNum || '0', 10) || 0);
      rail.dataset.absYear = String(absYear | 0);
      rail.dataset.fromTick = String(fromTick | 0);
      rail.dataset.toTick = String(toTick | 0);
      rail.style.setProperty('--tickCount', String(Math.max(0, spanCount)));

      // âœ… Delegated click handler â€“ guarantees clicks work even on child elements
      rail.addEventListener('click', (e) => {
        const tickEl = e.target.closest('.story-page');
        if (!tickEl) return;
        if (tickEl.dataset.storyId !== storyId) return;

        e.preventDefault();
        e.stopPropagation();
        scrollToStoryTickGroup(storyId, rail);
      });

      for (let i = 1; i <= spanCount; i++) {
        const absoluteTick = fromTick + (i - 1);

        const slot = document.createElement('div');
        slot.className = 'story-tick';
        slot.dataset.tick = String(absoluteTick);

        // Ordering metadata for global navigation
        slot.dataset.storyId = storyId;
        slot.dataset.seq = String(parseInt(page.seqNum || '0', 10) || 0);
        slot.dataset.scene = String(parseInt(page.sceneNum || '0', 10) || 0);
        slot.dataset.absYear = String(absYear | 0);
        slot.dataset.absTick = String(absoluteTick | 0);

        const isOn = onSet.has(absoluteTick);
        if (isOn) slot.classList.add('on');

        // Tick-page bars
        if (isOn) {
          const pc = pagesByTick.get(absoluteTick) | 0;
          for (let p = 0; p < Math.max(0, pc); p++) {
            const bar = document.createElement('div');
            bar.className = 'tick-page';
            slot.appendChild(bar);
          }
        }

        rail.appendChild(slot);
      }

      el.appendChild(rail);
      return el;
    }

    function renderStoryYearCellPages(cell, pages, yearTickCount, storyId, absYear) {
      const collection = document.createElement('div');
      collection.className = 'story-page-collection';
      collection.style.setProperty('--tickCount', String(Math.max(0, yearTickCount | 0)));

      for (const p of pages) {
        collection.appendChild(renderStoryPageBlock(p, yearTickCount, storyId, absYear));
      }

      cell.appendChild(collection);
    }

    /**
    * Build per-year story overlays to render as pages inside year cells.
    * Returns: Map<absYear, Array<{fromTick,toTick,onTicks,label,descHtml,pageNum}>>
    */
    function buildStoryPagesByYear(storyTimeline, maxTickByYear, ctx) {
      const out = new Map();

      const sequences = (storyTimeline.sequences || [])
        .slice()
        .sort((a, b) => (a.seq || 0) - (b.seq || 0));

      for (const seq of sequences) {
        const seqNum = String(parseInt(seq.seq || 0, 10) || 0).padStart(2, '0');
        const blocks = parseSequenceMapBlocks(seq.map);

        for (const block of blocks) {
          const sceneNum = block.scene || '??';
          const sceneTitle = String(block.sceneTitle || '').trim();

          // group refs by absYear (per scene)
          const byYear = new Map();

          for (const r of block.refs) {
            try {
              const rr = resolveStoryRef(r, ctx);
              if (!byYear.has(rr.absYear)) byYear.set(rr.absYear, []);
              byYear.get(rr.absYear).push({
                ...rr,
                category: r.category || '',
                pageCount: Number.isFinite(+r.pageCount) ? Math.max(1, (+r.pageCount | 0)) : 1
              });
            } catch {
              // ignore bad refs
            }
          }

          for (const [absYear, list] of byYear.entries()) {
            const ticks = list.map(x => x.tick || 0).filter(t => t > 0);
            const onTicks = Array.from(new Set(ticks)).sort((a, b) => a - b);
            if (!onTicks.length) continue;

            const fromTick = onTicks[0];
            const toTick = onTicks[onTicks.length - 1];

            // Aggregate page counts per tick (if multiple refs hit same tick, sum them)
            const pagesByTick = new Map();
            let totalPages = 0;

            for (const item of list) {
              const t = item.tick | 0;
              if (t <= 0) continue;
              const pc = item.pageCount | 0;
              if (!pagesByTick.has(t)) pagesByTick.set(t, 0);
              pagesByTick.set(t, (pagesByTick.get(t) | 0) + pc);
              totalPages += pc;
            }

            const headText = `${seqNum}.${sceneNum}`; // e.g. "01.02"
            const hoverText = sceneTitle ? `${headText} ${sceneTitle}` : headText;

            if (!out.has(absYear)) out.set(absYear, []);
            out.get(absYear).push({
              seqNum,
              sceneNum,
              sceneTitle,
              headText,
              hoverText,
              fromTick,
              toTick,
              onTicks,
              pagesByTick,
              totalPages
            });
          }
        }
      }

      return out;
    }

    function getOrderedStoryTickGroups(storyId) {
      const groups = Array.from(document.querySelectorAll(`.story-ticks[data-story-id="${storyId}"]`));

      // Order by: sequence -> scene -> absYear -> fromTick
      groups.sort((a, b) => {
        const aSeq = parseInt(a.dataset.seq || '0', 10) || 0;
        const bSeq = parseInt(b.dataset.seq || '0', 10) || 0;
        if (aSeq !== bSeq) return aSeq - bSeq;

        const aScene = parseInt(a.dataset.scene || '0', 10) || 0;
        const bScene = parseInt(b.dataset.scene || '0', 10) || 0;
        if (aScene !== bScene) return aScene - bScene;

        const aYear = parseInt(a.dataset.absYear || '0', 10) || 0;
        const bYear = parseInt(b.dataset.absYear || '0', 10) || 0;
        if (aYear !== bYear) return aYear - bYear;

        const aFrom = parseInt(a.dataset.fromTick || '0', 10) || 0;
        const bFrom = parseInt(b.dataset.fromTick || '0', 10) || 0;
        return aFrom - bFrom;
      });

      // Only keep groups that actually contain at least one "on" tick
      return groups.filter(g => g.querySelector('.story-tick.on'));
    }

    function clearStoryTickGroupActive(storyId) {
      document
        .querySelectorAll(`.story-ticks[data-story-id="${storyId}"][data-active]`)
        .forEach(el => el.removeAttribute('data-active'));
    }

    function setStoryTickGroupActive(storyId, groupEl) {
      if (!groupEl) return;

      const ordered = getOrderedStoryTickGroups(storyId);
      const idx = ordered.indexOf(groupEl);
      if (idx < 0) return;

      clearStoryTickGroupActive(storyId);

      groupEl.dataset.active = 'current';
      if (ordered[idx - 1]) ordered[idx - 1].dataset.active = 'previous';
      if (ordered[idx + 1]) ordered[idx + 1].dataset.active = 'next';
    }

    function scrollToStoryTickGroup(storyId, groupEl) {
      if (!groupEl) return;

      setStoryTickGroupActive(storyId, groupEl);

      groupEl.scrollIntoView({
        behavior: 'smooth',
        block: 'center',
        inline: 'center'
      });
    }

    function gotoAdjacentStoryTickGroup(storyId, direction, fallbackPageEl = null) {
      const ordered = getOrderedStoryTickGroups(storyId);
      if (!ordered.length) return;

      const current = document.querySelector(`.story-ticks[data-story-id="${storyId}"][data-active="current"]`);
      let idx = current ? ordered.indexOf(current) : -1;

      // If none active, try the first group inside this page
      if (idx < 0 && fallbackPageEl) {
        const inPage = fallbackPageEl.querySelector(`.story-ticks[data-story-id="${storyId}"]`);
        if (inPage) idx = ordered.indexOf(inPage);
      }

      if (idx < 0) idx = 0;

      const nextIdx = Math.max(0, Math.min(ordered.length - 1, idx + direction));
      scrollToStoryTickGroup(storyId, ordered[nextIdx]);
    }

    function renderTimelineSeparatorRow(grid, columns) {
      const labelCell = document.createElement('div');
      labelCell.className = 'cell label-cell timeline-separator';
      labelCell.textContent = ''; // keep blank
      grid.appendChild(labelCell);

      for (let i = 1; i < columns.length; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell timeline-separator';
        grid.appendChild(cell);
      }
    }

    /**********************
     * Utility / Parsing  *
     **********************/

    function splitBaseAndTick(token) {
      const raw = String(token || '').trim();
      // Match: <base>.<tick> where tick is 1+ digits (01, 2, 003, etc.)
      const m = raw.match(/^(.*)\.(\d+)$/);
      if (!m) return { base: raw, tick: 0 };

      const base = (m[1] || '').trim();
      const tick = parseInt(m[2], 10);
      return { base, tick: Number.isFinite(tick) ? tick : 0 };
    }

    function computeMaxTickByYear(visibleTimelines) {
      const ctx = { timelines: state.timelines, cache: new Map(), stack: [] };
      const maxTickByYear = new Map();

      for (const tl of visibleTimelines) {
        const anchorYear = resolveTimelineAnchorYear(tl, ctx);

        // IMPORTANT: only real events, not the generated anchor chip
        const allEvents = tl.events || [];

        for (const ev of allEvents) {
          const { base, tick } = splitBaseAndTick(ev.year);
          if (!base) continue;

          const absYear = parseYearToken(base, anchorYear, ctx).year;
          const prev = maxTickByYear.get(absYear) || 0;
          if (tick > prev) maxTickByYear.set(absYear, tick);
        }
      }

      return maxTickByYear;
    }

    function ensureBookOutlineModal() {
      let backdrop = document.getElementById('book-outline-backdrop');
      if (backdrop) return backdrop;

      backdrop = document.createElement('div');
      backdrop.id = 'book-outline-backdrop';
      backdrop.className = 'modal-backdrop';
      backdrop.style.display = 'none';

      backdrop.innerHTML = `
    <div class="modal" role="dialog" aria-modal="true" aria-label="Book outline">
      <div class="modal-header">
        <h2 id="book-outline-title"></h2>
        <button class="modal-close" type="button" aria-label="Close">âœ•</button>
      </div>
      <div class="modal-body" id="book-outline-body"></div>
    </div>
  `;

      backdrop.addEventListener('click', (e) => {
        if (e.target === backdrop) closeBookOutline();
      });

      const closeBtn = backdrop.querySelector('.modal-close');
      closeBtn.addEventListener('click', closeBookOutline);

      window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeBookOutline();
      });

      document.body.appendChild(backdrop);
      return backdrop;
    }

    function openBookOutline(storyTimelineId) {
      const st = (state.storyTimelines || []).find(x => x.id === storyTimelineId);
      if (!st) return;

      const backdrop = ensureBookOutlineModal();
      const titleEl = backdrop.querySelector('#book-outline-title');
      const bodyEl = backdrop.querySelector('#book-outline-body');

      // ðŸ”¹ Calculate total pages for entire book
      const ctx = { timelines: state.timelines, cache: new Map(), stack: [] };
      let totalPages = 0;

      const sequences = (st.sequences || []).slice();
      for (const seq of sequences) {
        const blocks = parseSequenceMapBlocks(seq.map);
        for (const block of blocks) {
          for (const r of (block.refs || [])) {
            const pc = Number.isFinite(+r.pageCount)
              ? Math.max(1, (+r.pageCount | 0))
              : 1;
            totalPages += pc;
          }
        }
      }

      const safeTitle = escapeHtml(st.title || '(Story Timeline)');
      const pagesText = totalPages ? `(${totalPages} pages)` : '';

      titleEl.innerHTML = `
    ${safeTitle}
    <span class="outline-book-pages">${escapeHtml(pagesText)}</span>
  `;

      bodyEl.innerHTML = buildBookOutlineHtml(st);

      backdrop.style.display = 'flex';
    }

    function closeBookOutline() {
      const backdrop = document.getElementById('book-outline-backdrop');
      if (!backdrop) return;
      backdrop.style.display = 'none';
    }

    function buildBookOutlineHtml(storyTimeline) {
      const ctx = { timelines: state.timelines, cache: new Map(), stack: [] };

      // Normalise + sort sequences
      const sequences = (storyTimeline.sequences || [])
        .slice()
        .sort((a, b) => (a.seq || 0) - (b.seq || 0));

      // Helpers
      const pad2 = (n) => String(parseInt(n, 10) || 0).padStart(2, '0');

      const findEventByAbsYearTick = (timeline, absYear, tick) => {
        const tlCtx = { timelines: state.timelines, cache: new Map(), stack: [] };
        const anchorYear = resolveTimelineAnchorYear(timeline, tlCtx);

        // Find all events matching absYear + tick
        const matches = [];
        for (const ev of (timeline.events || [])) {
          try {
            const { base, tick: t } = splitBaseAndTick(ev.year);
            if (!base) continue;
            const y = parseYearToken(base, anchorYear, tlCtx).year;
            if (y === absYear && (t || 0) === (tick || 0)) {
              matches.push(ev);
            }
          } catch {
            // ignore
          }
        }
        return matches;
      };

      let html = '';

      for (const seq of sequences) {
        const seqNum = pad2(seq.seq);
        const seqTitle = String(seq.title || '').trim();
        const seqTitleText = seqTitle || '(Untitled Sequence)';

        html += `
  <div class="outline-seq">
    <h3>
      <span class="outline-seq-num">${escapeHtml(seqNum)}</span>
      ${escapeHtml(seqTitleText)}
    </h3>
`;

        const blocks = parseSequenceMapBlocks(seq.map);

        for (const block of blocks) {
          const sceneNum = pad2(block.scene);
          const sceneTitleText = String(block.sceneTitle || '').trim() || '(Untitled Scene)';

          // Resolve refs â†’ group by (absYear, tick, timeline)
          const resolved = [];
          for (const r of (block.refs || [])) {
            try {
              const rr = resolveStoryRef(r, ctx);
              const tl = state.timelines.find(t => t.id === rr.timelineId);
              if (!tl) continue;
              resolved.push({
                timeline: tl,
                absYear: rr.absYear,
                tick: rr.tick || 0,
                pageCount: Number.isFinite(+r.pageCount) ? Math.max(1, (+r.pageCount | 0)) : 1
              });
            } catch {
              // ignore bad refs
            }
          }

          // Total pages for the scene (sum of page counts in the block)
          const totalPages = resolved.reduce((acc, x) => acc + (x.pageCount || 0), 0);
          const pagesText = totalPages ? `(${totalPages} pages)` : '';

          html += `
<div class="outline-scene">
  <div class="outline-scene-title">
    <span class="outline-scene-seq">${escapeHtml(seqNum)}</span>
    <span class="outline-scene-num">${escapeHtml(sceneNum)}</span>
    ${escapeHtml(sceneTitleText)}
    <span class="muted">${escapeHtml(pagesText)}</span>
  </div>
`;

          // Group by timeline title (keep stable order by appearance)
          const tlOrder = [];
          const byTl = new Map();
          for (const item of resolved) {
            const key = item.timeline.id;
            if (!byTl.has(key)) {
              byTl.set(key, []);
              tlOrder.push(key);
            }
            byTl.get(key).push(item);
          }

          for (const tlId of tlOrder) {
            const items = byTl.get(tlId) || [];
            const tl = items[0]?.timeline;
            if (!tl) continue;

            const tlColor = tl.color || '#888';

            html += `<div class="outline-tl" style="--tlCol:${escapeHtml(tlColor)}">`;
            html += `<div class="outline-tl-title">${escapeHtml(tl.title || '(Timeline)')}</div>`;

            // For each ref, list matching event(s) at that absYear+tick
            for (const it of items) {
              const evs = findEventByAbsYearTick(tl, it.absYear, it.tick);

              // If multiple events exist at the same tick, list them all
              if (!evs.length) {
                html += `
              <div class="outline-ev">
                <div class="ev-title">${escapeHtml('(No event found for this tick)')}</div>
              </div>
            `;
                continue;
              }

              for (const ev of evs) {
                const title = String(ev.title || '').trim() || '(Untitled Event)';
                const desc = String(ev.desc || '').trim();

                html += `<div class="outline-ev">`;
                html += `<div class="ev-title">${escapeHtml(title)}</div>`;
                if (desc) html += `<div class="ev-desc">${markdownToHtml(desc)}</div>`;
                html += `</div>`;
              }
            }

            html += `</div>`; // .outline-tl
          }

          html += `</div>`; // .outline-scene
        }

        html += `</div>`; // .outline-seq
      }

      return html || `<div class="muted">No outline data found.</div>`;
    }



    // Add this helper (or replace your existing one if present)
    function formatWithCommas(x) {
      // Inserts commas every 3 digits, e.g. 1234567 -> 1,234,567
      return String(x).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }

    // Replace your current formatYearSigned with this version
    function formatYearSigned(y) {
      const abs = Math.abs(y);
      const numStr = abs >= 10000 ? formatWithCommas(abs) : String(abs);
      return y < 0 ? `${numStr}bc` : numStr;
    }

    // Wrap parenthetical parts of a title in <span>(...)</span> safely.
    function formatTitleWithParens(title) {
      if (!title) return '';
      const safe = escapeHtml(String(title));
      // Turn (...) â†’ <span>(...)</span> (supports multiple sets)
      return safe.replace(/\(([^)]+)\)/g, (_m, inner) => `<span>(${inner})</span>`);
    }

    function getAnchorEvent(tl) {
      if (!tl) return null;

      return {
        year: String(tl.year || '2000'),   // token, not forced numeric
        title: tl.title || '(Untitled)',
        desc: tl.description || '',
        __isAnchor: true,
      };
    }


    // Replace your current parseYearToken with this version
    function parseYearToken(str, baseYear = 2000, ctx = null) {
      if (typeof str !== 'string') throw new Error('Year must be a string');
      const s = str.trim();

      const timelines =
        ctx?.timelines ||
        (typeof state !== 'undefined' ? state.timelines : []) ||
        [];

      const anchor = Number.isFinite(+baseYear) ? +baseYear : 2000;

      // 1) Plain numeric / BC / Relative: 1999 | 300bc | 10yb | 10ya
      {
        const m = s.toLowerCase().match(/^(\d+)(bc|yb|ya)?$/);
        if (m) {
          const n = parseInt(m[1], 10);
          if (Number.isNaN(n)) throw new Error('Invalid year number: ' + str);

          const suffix = m[2] || '';

          let year;
          if (suffix === 'bc') {
            year = -n;
          } else if (suffix === 'yb') {
            // NEW: years before the timeline anchor
            year = anchor - n;
          } else if (suffix === 'ya') {
            // NEW: years after the timeline anchor
            year = anchor + n;
          } else {
            // Absolute year
            year = n;
          }

          return { year, isBC: year < 0 };
        }
      }

      // 2) "After another anchor": 5aKANTO  (years after timeline "Kanto" anchor year)
      {
        const m = s.match(/^(\d+)\s*a\s*(.+)$/i);
        if (m) {
          const offset = parseInt(m[1], 10);
          const name = m[2].trim();
          if (!name) throw new Error('Invalid anchor reference (missing name): ' + str);

          const ref = getTimelineByName(name, timelines);
          if (!ref) throw new Error(`Unknown anchor timeline "${name}" in token: ${str}`);

          const localCtx = ctx || { timelines, cache: new Map(), stack: [] };
          const refAnchorYear = resolveTimelineAnchorYear(ref, localCtx);

          const year = refAnchorYear + offset;
          return { year, isBC: year < 0 };
        }
      }

      throw new Error('Invalid year token: ' + str);
    }

    const sortEventsByYear = (a, b) => {
      const ay = parseYearToken(a.year).year;
      const by = parseYearToken(b.year).year;
      return ay - by;
    };

    function collectAllYears(timelines) {
      const set = new Set();
      const ctx = { timelines, cache: new Map(), stack: [] };

      for (const tl of timelines) {
        const anchorYear = resolveTimelineAnchorYear(tl, ctx);

        // include anchor year
        set.add(anchorYear);

        // include events (ya is relative to *this* timeline's resolved anchor year)
        for (const ev of tl.events || []) {
          const { base } = splitBaseAndTick(ev.year);
          if (!base) continue;
          set.add(parseYearToken(base, anchorYear, ctx).year);
        }
      }

      return Array.from(set).sort((a, b) => a - b);
    }


    function resolveImageSrc(input) {
      if (!input) return '';
      const s = String(input).trim();
      if (/^https?:\/\//i.test(s)) return s;     // absolute URL
      if (s.startsWith('/')) return s;           // absolute site path
      return `images/${s}`;                      // slug/subpath â†’ images/<path>
    }

    let descTooltipEl = null;

    function ensureDescTooltip() {
      if (descTooltipEl) return descTooltipEl;

      const el = document.createElement('div');
      el.id = 'desc-tooltip';
      el.style.position = 'fixed';
      el.style.zIndex = '9999';
      el.style.pointerEvents = 'none';
      el.style.display = 'none';

      document.body.appendChild(el);
      descTooltipEl = el;

      // Hide tooltip on scroll / click / escape
      window.addEventListener('scroll', hideDescTooltip, true);
      window.addEventListener('pointerdown', hideDescTooltip, true);
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape') hideDescTooltip(); });

      return el;
    }

    function showDescTooltip(html, clientX, clientY) {
      const el = ensureDescTooltip();
      el.innerHTML = html;

      // show first so we can measure
      el.style.display = 'block';

      const pad = 12;
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const rect = el.getBoundingClientRect();

      let x = clientX + pad;
      let y = clientY + pad;

      if (x + rect.width + pad > vw) x = Math.max(pad, vw - rect.width - pad);
      if (y + rect.height + pad > vh) y = Math.max(pad, vh - rect.height - pad);

      el.style.left = `${x}px`;
      el.style.top = `${y}px`;
    }

    function hideDescTooltip() {
      if (!descTooltipEl) return;
      descTooltipEl.style.display = 'none';
    }


    /** Simple, safe-ish markdown â†’ HTML for chips.
 * Supports: links [text](https://...), **bold**, *italic*, `code`, and line breaks.
 * Intentionally conservative to avoid XSS and layout surprises.
 */
    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }
    function markdownToHtml(md) {
      if (!md) return '';
      let s = escapeHtml(String(md).replace(/\r\n/g, '\n'));

      // Inline code first to protect contents
      s = s.replace(/`([^`]+)`/g, (_m, code) => `<code>${code}</code>`);

      // Links: [label](https://example.com) â€” only allow http/https
      s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g, (_m, label, url) => {
        const safeLabel = escapeHtml(label);
        const safeUrl = escapeHtml(url);
        return `<a href="${safeUrl}" target="_blank" rel="noopener">${safeLabel}</a>`;
      });

      // Bold, then italics (simple, non-greedy)
      s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      s = s.replace(/\*([^*]+)\*/g, '<em>$1</em>');

      // Line breaks
      s = s.replace(/\n/g, '<br>');

      return s;
    }


    /*****************
     * Theme toggle  *
     *****************/
    function applyTheme() {
      document.body.setAttribute('data-theme', state.theme);
    }
    function toggleTheme() {
      state.theme = state.theme === 'light' ? 'dark' : 'light';
      applyTheme();
    }

    /**********************
     * Rendering (Grid)   *
     **********************/

    function makeConfirmable(btn, onConfirm, {
      idleText = btn.textContent || 'Delete',
      confirmText = 'Confirm',
      timeoutMs = 3000
    } = {}) {
      let timer = null;

      const reset = () => {
        btn.textContent = idleText;
        btn.classList.remove('confirm');
        btn.dataset.confirm = '';
        if (timer) { clearTimeout(timer); timer = null; }
      };

      btn.onclick = (e) => {
        if (btn.dataset.confirm === 'true') {
          reset();
          onConfirm(e);
          return;
        }
        btn.dataset.confirm = 'true';
        btn.textContent = confirmText;
        btn.classList.add('confirm');
        timer = setTimeout(reset, timeoutMs);
      };

      // Optional niceties
      btn.addEventListener('mouseleave', reset);
      btn.addEventListener('blur', reset);

      return reset;
    }


    function renderTimelineList() {
      const list = document.getElementById('timeline-list');
      list.innerHTML = '';

      // Track current drag state locally
      let dragId = null;

      const clearDragClasses = () => {
        list.querySelectorAll('.option').forEach(el => {
          el.classList.remove('dragging', 'drag-over');
        });
      };

      const onDropReorder = (dropId) => {
        if (!dragId || dragId === dropId) return;

        const from = indexOfTimelineId(dragId);
        const to = indexOfTimelineId(dropId);
        if (from < 0 || to < 0) return;

        moveTimeline(from, to);

        // Re-render everything that depends on order
        renderTimelineList();
        renderToggleBar();
        renderYearGrid();

        // Keep selection stable
        if (state.selectedTimelineId) {
          const selectedEl = list.querySelector(`.option[data-id="${state.selectedTimelineId}"]`);
          if (selectedEl) selectedEl.setAttribute('aria-selected', 'true');
        }
      };

      // Build options
      for (const tl of state.timelines) {
        const isSelected = (state.selectedEditorKind === 'timeline') && (tl.id === state.selectedTimelineId);

        const opt = document.createElement('div');
        opt.className = 'option';
        opt.setAttribute('role', 'option');
        opt.setAttribute('data-id', tl.id);
        opt.setAttribute('aria-selected', isSelected ? 'true' : 'false');
        opt.setAttribute('tabindex', isSelected ? '0' : '-1');
        opt.setAttribute('data-state', 'default');
        opt.style.setProperty('--tlCol', tl.color || '#8aa');
        opt.textContent = tl.title || '(Untitled)';

        // Click + keyboard behaviour (your existing behaviour)
        opt.addEventListener('click', () => selectTimeline(tl.id));
        opt.addEventListener('keydown', (e) => handleListboxKey(e, opt));

        // --- Drag & Drop reordering ---
        opt.draggable = true;

        opt.addEventListener('dragstart', (e) => {
          dragId = tl.id;
          opt.classList.add('dragging');

          // Some browsers need data set for DnD to work
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', tl.id);
        });

        opt.addEventListener('dragend', () => {
          dragId = null;
          clearDragClasses();
        });

        opt.addEventListener('dragenter', (e) => {
          e.preventDefault();
          if (!dragId || dragId === tl.id) return;
          opt.classList.add('drag-over');
        });

        opt.addEventListener('dragleave', () => {
          opt.classList.remove('drag-over');
        });

        opt.addEventListener('dragover', (e) => {
          // Must prevent default to allow drop
          e.preventDefault();
          if (!dragId || dragId === tl.id) return;
          e.dataTransfer.dropEffect = 'move';
        });

        opt.addEventListener('drop', (e) => {
          e.preventDefault();

          // Prefer the stored dragId, but also read transfer data (safety)
          const droppedOnId = tl.id;
          const fromId = dragId || e.dataTransfer.getData('text/plain');

          dragId = fromId;
          onDropReorder(droppedOnId);
          clearDragClasses();
        });

        list.appendChild(opt);
      }

      // Ensure at least one is tabbable for keyboard users
      const focusable = list.querySelector('[tabindex="0"]') || list.querySelector('.option');
      if (focusable && document.activeElement.closest('#timeline-list')) {
        focusable.focus();
      }
    }


    function selectTimeline(id) {
      state.selectedEditorKind = 'timeline';
      state.selectedEditorKind = 'timeline';
      state.selectedTimelineId = id;
      state.selectedStoryTimelineId = null;
      state.selectedStoryTimelineId = null;
      renderTimelineList();
      renderStoryTimelineList();
      renderTimelineEditor();   // refresh details panel
    }

    function selectStoryTimeline(id) {
      state.selectedEditorKind = 'story';
      state.selectedStoryTimelineId = id;
      state.selectedTimelineId = null;
      renderTimelineList();
      renderStoryTimelineList();
      renderTimelineEditor();   // refresh details panel
    }

    function renderStoryTimelineList() {
      const list = document.getElementById('story-timeline-list');
      if (!list) return;
      list.innerHTML = '';

      for (const st of state.storyTimelines) {
        const isSelected = st.id === state.selectedStoryTimelineId && state.selectedEditorKind === 'story';

        const opt = document.createElement('div');
        opt.className = 'option';
        opt.setAttribute('role', 'option');
        opt.setAttribute('data-id', st.id);
        opt.setAttribute('aria-selected', isSelected ? 'true' : 'false');
        opt.setAttribute('tabindex', isSelected ? '0' : '-1');
        opt.textContent = st.title || '(Story)';

        opt.addEventListener('click', () => selectStoryTimeline(st.id));
        opt.addEventListener('keydown', (e) => handleStoryListboxKey(e, opt));

        list.appendChild(opt);
      }

      const focusable = list.querySelector('[tabindex="0"]') || list.querySelector('.option');
      if (focusable && document.activeElement.closest('#story-timeline-list')) {
        focusable.focus();
      }
    }

    function handleStoryListboxKey(e, currentOpt) {
      const list = document.getElementById('story-timeline-list');
      const opts = Array.from(list.querySelectorAll('.option'));
      const idx = opts.indexOf(currentOpt);

      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        currentOpt.click();
        return;
      }

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        const next = opts[Math.min(idx + 1, opts.length - 1)];
        if (next) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          next.setAttribute('tabindex', '0');
          next.focus();
        }
        return;
      }

      if (e.key === 'ArrowUp') {
        e.preventDefault();
        const prev = opts[Math.max(idx - 1, 0)];
        if (prev) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          prev.setAttribute('tabindex', '0');
          prev.focus();
        }
        return;
      }

      if (e.key === 'Home') {
        e.preventDefault();
        const first = opts[0];
        if (first) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          first.setAttribute('tabindex', '0');
          first.focus();
        }
      }
      if (e.key === 'End') {
        e.preventDefault();
        const last = opts[opts.length - 1];
        if (last) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          last.setAttribute('tabindex', '0');
          last.focus();
        }
      }
    }

    function handleListboxKey(e, currentOpt) {
      const list = document.getElementById('timeline-list');
      const opts = Array.from(list.querySelectorAll('.option'));
      const idx = opts.indexOf(currentOpt);

      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        currentOpt.click();
        return;
      }

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        const next = opts[Math.min(idx + 1, opts.length - 1)];
        if (next) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          next.setAttribute('tabindex', '0');
          next.focus();
        }
        return;
      }

      if (e.key === 'ArrowUp') {
        e.preventDefault();
        const prev = opts[Math.max(idx - 1, 0)];
        if (prev) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          prev.setAttribute('tabindex', '0');
          prev.focus();
        }
        return;
      }

      // Optional: Home/End keys
      if (e.key === 'Home') {
        e.preventDefault();
        const first = opts[0];
        if (first) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          first.setAttribute('tabindex', '0');
          first.focus();
        }
      }
      if (e.key === 'End') {
        e.preventDefault();
        const last = opts[opts.length - 1];
        if (last) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          last.setAttribute('tabindex', '0');
          last.focus();
        }
      }
    }


    function renderToggleBar() {
      // Ensure we have a container just before the grid
      const viewport = document.querySelector('.viewport');
      const gridEl = document.getElementById('grid');

      let container = viewport.querySelector('.toggles-container');
      if (!container) {
        container = document.createElement('div');
        container.className = 'toggles-container';
        viewport.insertBefore(container, gridEl);
      }
      container.innerHTML = '';

      // --- Timeline toggles (existing behaviour) ---
      let tlBar = container.querySelector('.timeline-toggles');
      if (!tlBar) {
        tlBar = document.createElement('div');
        tlBar.className = 'timeline-toggles';
        container.appendChild(tlBar);
      }
      tlBar.innerHTML = '';

      if (!state.timelines.length) {
        tlBar.innerHTML = '<span class="muted small">No timelines yet.</span>';
      } else {
        for (const tl of state.timelines) {
          const id = `tgl_${tl.id}`;
          const wrap = document.createElement('label');
          wrap.className = 'toggle';
          wrap.style.setProperty('--tlCol', tl.color || '#8aa');

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.id = id;
          cb.checked = !state.hiddenTimelineIds.has(tl.id);
          cb.onchange = () => {
            if (cb.checked) state.hiddenTimelineIds.delete(tl.id);
            else state.hiddenTimelineIds.add(tl.id);
            renderYearGrid();
          };

          const txt = document.createElement('span');
          txt.className = 'label';
          txt.textContent = tl.title || '(Untitled)';

          wrap.appendChild(cb);
          wrap.appendChild(txt);
          tlBar.appendChild(wrap);
        }
      }

      // --- Story timeline toggles ---
      let stBar = container.querySelector('.story-toggles');
      if (!stBar) {
        stBar = document.createElement('div');
        stBar.className = 'story-toggles';
        container.appendChild(stBar);
      }
      stBar.innerHTML = '';

      if (!state.storyTimelines.length) {
        stBar.innerHTML = '<span class="muted small">No story timelines yet.</span>';
      } else {
        for (const st of state.storyTimelines) {
          const wrap = document.createElement('label');
          wrap.className = 'toggle';

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.checked = !state.hiddenStoryTimelineIds.has(st.id);
          cb.onchange = () => {
            if (cb.checked) state.hiddenStoryTimelineIds.delete(st.id);
            else state.hiddenStoryTimelineIds.add(st.id);
            renderYearGrid();
          };

          const txt = document.createElement('span');
          txt.className = 'label';
          txt.textContent = st.title || '(Story)';

          wrap.appendChild(cb);
          wrap.appendChild(txt);
          stBar.appendChild(wrap);
        }
      }

      // --- Content toggles (NEW) ---
      let contentBar = container.querySelector('.content-toggles');
      if (!contentBar) {
        contentBar = document.createElement('div');
        contentBar.className = 'content-toggles';
        container.appendChild(contentBar);
      }
      contentBar.innerHTML = '';

      // helper to build a switch
      const mkSwitch = (labelText, checked, onChange) => {
        const lbl = document.createElement('label');
        lbl.className = 'toggle content-toggle';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = checked;
        cb.onchange = () => { onChange(cb.checked); };

        const text = document.createElement('span');
        text.className = 'label';
        text.textContent = labelText;

        lbl.appendChild(cb);
        lbl.appendChild(text);
        return lbl;
      };

      // Descriptions
      contentBar.appendChild(
        mkSwitch('Descriptions', state.showDescriptions, (v) => {
          state.showDescriptions = v;
          renderYearGrid();
        })
      );

    }

    function renderApp() {
      applyTheme();
      renderHeader();
      renderToggleBar();
      renderYearGrid();
      renderEditorUI();
    }

    function renderHeader() {
      document.getElementById('btn-theme').onclick = toggleTheme;
      document.getElementById('btn-edit').onclick = () => enterEditMode();
      // Import/Download now live in the editor header
    }

    function renderStoryTimelineRow(grid, storyTimeline, columns, maxTickByYear) {
      const ctx = { timelines: state.timelines, cache: new Map(), stack: [] };

      // Build pages per year
      const pagesByYear = buildStoryPagesByYear(storyTimeline, maxTickByYear, ctx);

      // --- NEW: total pages across the whole story timeline ---
      let totalPagesAll = 0;
      for (const pages of pagesByYear.values()) {
        for (const p of pages) {
          const n = Number.isFinite(+p.totalPages) ? (+p.totalPages | 0) : 0;
          totalPagesAll += Math.max(0, n);
        }
      }

      // Label cell
      const label = document.createElement('div');
      label.className = 'cell label-cell story-label';

      // Used by CSS ::after
      label.dataset.pages = String(totalPagesAll);

      const labelinner = document.createElement('div');
      labelinner.className = 'label-inner';
      labelinner.textContent = storyTimeline.title || '(Story Timeline)';
      label.appendChild(labelinner);
      grid.appendChild(label);
      label.style.cursor = 'pointer';
      label.title = 'Click to view book outline';
      label.addEventListener('click', () => openBookOutline(storyTimeline.id));

      // Cells
      for (let i = 1; i < columns.length; i++) {
        const col = columns[i];

        if (col.type === 'gap') {
          const cell = document.createElement('div');
          cell.className = 'cell gap-body story-gap';
          const marker = document.createElement('div');
          marker.className = 'event collapse';
          marker.textContent = '~';
          cell.appendChild(marker);
          grid.appendChild(cell);
          continue;
        }

        const y = col.year;
        const cell = document.createElement('div');
        cell.className = 'cell year-body story-year';

        const tickCount = maxTickByYear.get(y) || 0;
        const pages = pagesByYear.get(y) || [];

        if (!pages.length) {
          grid.appendChild(cell);
          continue;
        }

        renderStoryYearCellPages(cell, pages, tickCount, storyTimeline.id, y);
        grid.appendChild(cell);
      }
    }

    function renderYearGrid() {
      const grid = document.getElementById('grid');
      grid.innerHTML = '';

      // filter visible timelines
      const visibleTimelines = state.timelines.filter(t => !state.hiddenTimelineIds.has(t.id));

      if (!visibleTimelines.length) {
        grid.innerHTML = '<div class="muted">No timelines selected. Toggle one above to show it.</div>';
        return;
      }

      // collect years from VISIBLE ones only
      const years = collectAllYears(visibleTimelines);
      const { columns, colCount } = buildYearColumns(years);

      // NEW: per-year maximum tick count across visible timelines
      const maxTickByYear = computeMaxTickByYear(visibleTimelines);

      grid.style.gridTemplateColumns = `var(--label-col-w) repeat(${colCount - 1}, var(--year-col-w))`;

      // header...
      const labelHeader = document.createElement('div');
      labelHeader.className = 'cell header label-header';
      labelHeader.textContent = '';
      grid.appendChild(labelHeader);

      for (let i = 1; i < columns.length; i++) {
        const col = columns[i];
        const cell = document.createElement('div');
        if (col.type === 'year') {
          cell.className = 'cell header year-header';
          cell.textContent = formatYearSigned(col.year);
        } else {
          cell.className = 'cell header gap-header';
          cell.textContent = 'â€¦';
        }
        grid.appendChild(cell);
      }

      // --- Story timelines (render above normal timelines) ---
      const visibleStoryTimelines = state.storyTimelines.filter(st => !state.hiddenStoryTimelineIds.has(st.id));
      for (const st of visibleStoryTimelines) {
        renderStoryTimelineRow(grid, st, columns, maxTickByYear);
      }

      if (state.storyTimelines?.length && state.timelines?.length) {
        renderTimelineSeparatorRow(grid, columns);
      }

      // body rows ONLY for visible timelines
      for (const tl of visibleTimelines) {
        renderTimelineRow(grid, tl, columns, maxTickByYear);
      }
    }


    function buildYearColumns(years) {
      const columns = [{ type: 'label' }];
      if (years.length === 0) return { columns, colCount: 1 };
      for (let i = 0; i < years.length; i++) {
        const y = years[i];
        columns.push({ type: 'year', year: y });
        if (i < years.length - 1) {
          const next = years[i + 1];
          if (next - y > 1) columns.push({ type: 'gap' });
        }
      }
      return { columns, colCount: columns.length };
    }

    function renderTimelineRow(grid, timeline, columns, maxTickByYear) {
      const tlCol = timeline.color || '#8aa';
      const ctx = { timelines: state.timelines, cache: new Map(), stack: [] };
      const anchorYear = resolveTimelineAnchorYear(timeline, ctx);

      // Map: absYear -> { baseEvents:[{ev, base}], ticksByN: Map<int, [{ev, base}]> }
      const byYear = new Map();
      const ensureBucket = (absYear) => {
        if (!byYear.has(absYear)) byYear.set(absYear, { baseEvents: [], ticksByN: new Map() });
        return byYear.get(absYear);
      };

      const pushTick = (bucket, tick, ev, base) => {
        if (!bucket.ticksByN.has(tick)) bucket.ticksByN.set(tick, []);
        bucket.ticksByN.get(tick).push({ ev, base });
      };

      // 2) Normal events (sorted by abs year then tick)
      const sortedEvents = (timeline.events || []).slice().sort((a, b) => {
        const aa = splitBaseAndTick(a.year);
        const bb = splitBaseAndTick(b.year);
        const ay = parseYearToken(aa.base, anchorYear, ctx).year;
        const by = parseYearToken(bb.base, anchorYear, ctx).year;
        if (ay !== by) return ay - by;
        return (aa.tick || 0) - (bb.tick || 0);
      });

      for (const ev of sortedEvents) {
        const { base, tick } = splitBaseAndTick(ev.year);
        if (!base) continue;

        const y = parseYearToken(base, anchorYear, ctx).year;
        const bucket = ensureBucket(y);

        if (tick > 0) pushTick(bucket, tick, ev, base);
        else bucket.baseEvents.push({ ev, base });
      }

      // Label cell
      const label = document.createElement('div');
      label.className = 'cell label-cell';
      const labelinner = document.createElement('div');
      labelinner.className = 'label-inner';
      labelinner.textContent = timeline.title || '(Untitled)';
      label.appendChild(labelinner);
      label.style.setProperty('--tlCol', tlCol);
      grid.appendChild(label);

      // Cells
      for (let i = 1; i < columns.length; i++) {
        const col = columns[i];

        if (col.type === 'gap') {
          const cell = document.createElement('div');
          cell.className = 'cell gap-body';
          cell.style.setProperty('--tlCol', tlCol);
          const marker = document.createElement('div');
          marker.className = 'event collapse';
          marker.textContent = '~';
          cell.appendChild(marker);
          grid.appendChild(cell);
          continue;
        }

        const y = col.year;
        const cell = document.createElement('div');
        cell.className = 'cell year-body';
        cell.style.setProperty('--tlCol', tlCol);

        const bucket = byYear.get(y);
        if (!bucket) {
          grid.appendChild(cell);
          continue;
        }

        const tickCount = maxTickByYear?.get(y) || 0;
        const hasTicks = bucket.ticksByN.size > 0;

        if (!hasTicks) {
          // Base event(s) exist but there are no ticks in this year â†’ mark as empty
          for (const be of bucket.baseEvents) {
            cell.appendChild(renderEventChip(be.ev, { empty: true }));
          }
          grid.appendChild(cell);
          continue;
        }

        // --- NEW: choose container base by matching tick base token ---
        // Find the first tick's base token (lowest tick, first entry)
        let preferredBaseToken = null;
        const tickNums = Array.from(bucket.ticksByN.keys()).sort((a, b) => a - b);
        if (tickNums.length) {
          const firstTickList = bucket.ticksByN.get(tickNums[0]) || [];
          preferredBaseToken = firstTickList[0]?.base || null;
        }

        // Prefer a non-anchor base event matching preferredBaseToken (e.g., "0ya")
        let containerBaseEntry =
          (preferredBaseToken
            ? bucket.baseEvents.find(be => be.base === preferredBaseToken)
            : null) || bucket.baseEvents[0] || null;

        const containerChip = renderYearContainerChip({
          baseEvent: containerBaseEntry ? containerBaseEntry.ev : null,
          tickEventsByN: bucket.ticksByN,
          tickCount,
          missing: !containerBaseEntry,
          timelineTitle: timeline.title,
          absYear: y
        });

        cell.appendChild(containerChip);

        // Build a set of base tokens that actually have ticks (e.g. "0ya", "1ya")
        const tickBaseSet = new Set();
        for (const arr of bucket.ticksByN.values()) {
          for (const entry of (arr || [])) {
            if (entry?.base) tickBaseSet.add(entry.base);
          }
        }

        // Render extra base events (excluding the one used as container)
        // If a base eventâ€™s token isn't used by any ticks, mark it as empty
        for (const be of bucket.baseEvents) {
          if (containerBaseEntry && be === containerBaseEntry) continue;
          const isEmpty = !tickBaseSet.has(be.base);
          cell.appendChild(renderEventChip(be.ev, { empty: isEmpty }));
        }

        grid.appendChild(cell);
      }
    }
    function renderSceneTickEventCard(ev) {
      const card = document.createElement('div');
      card.className = 'scenetick-event';

      const hasDesc = !!(ev.desc && String(ev.desc).trim()) && state.showDescriptions;
      const hasHiddenDesc = !!(ev.desc && String(ev.desc).trim()) && !state.showDescriptions;

      if (hasHiddenDesc) {
        card.addEventListener('pointerenter', (e) => {
          showDescTooltip(
            `<div class="chip-desc">${markdownToHtml(ev.desc)}</div>`,
            e.clientX,
            e.clientY
          );
        });
        card.addEventListener('pointermove', (e) => {
          showDescTooltip(
            `<div class="chip-desc">${markdownToHtml(ev.desc)}</div>`,
            e.clientX,
            e.clientY
          );
        });
        card.addEventListener('pointerleave', hideDescTooltip);
      }

      const body = document.createElement('div');
      body.className = 'tick-body';

      const t = document.createElement('div');
      t.className = 'tick-title';
      t.innerHTML = formatTitleWithParens(ev.title || '');
      body.appendChild(t);

      if (hasDesc) {
        const d = document.createElement('div');
        d.className = 'tick-desc';
        d.innerHTML = markdownToHtml(ev.desc);
        body.appendChild(d);
      }

      card.appendChild(body);
      return card;
    }

    function renderYearContainerChip({ baseEvent, tickEventsByN, tickCount, missing, timelineTitle, absYear }) {
      const chip = document.createElement('div');
      chip.className = 'event chip year-container';

      const hasBase = !!baseEvent;

      // âœ… NEW: mark base event chips as empty if there are NO tick events
      let hasAnyTickEvents = false;
      if (tickEventsByN instanceof Map) {
        for (const arr of tickEventsByN.values()) {
          if (Array.isArray(arr) && arr.length > 0) {
            hasAnyTickEvents = true;
            break;
          }
        }
      }
      if (hasBase && !hasAnyTickEvents) {
        chip.classList.add('empty');
      }

      const baseHasDesc = hasBase && !!(baseEvent.desc && String(baseEvent.desc).trim()) && state.showDescriptions;
      const baseHasHiddenDesc = hasBase && !!(baseEvent.desc && String(baseEvent.desc).trim()) && !state.showDescriptions;

      if (baseHasHiddenDesc) {
        chip.addEventListener('pointerenter', (e) => {
          showDescTooltip(
            `<div class="chip-desc">${markdownToHtml(baseEvent.desc)}</div>`,
            e.clientX,
            e.clientY
          );
        });
        chip.addEventListener('pointermove', (e) => {
          showDescTooltip(
            `<div class="chip-desc">${markdownToHtml(baseEvent.desc)}</div>`,
            e.clientX,
            e.clientY
          );
        });
        chip.addEventListener('pointerleave', hideDescTooltip);
      }

      const content = document.createElement('div');
      content.className = 'chip-content';

      const title = document.createElement('div');
      title.className = 'chip-title';

      if (hasBase) {
        title.innerHTML = formatTitleWithParens(baseEvent.title || '');
      } else {
        const safeTl = escapeHtml(timelineTitle || '');
        const safeYear = escapeHtml(formatYearSigned(absYear));
        title.innerHTML = `${safeTl} ${safeYear} Events`;
      }

      content.appendChild(title);

      if (baseHasDesc) {
        const desc = document.createElement('div');
        desc.className = 'chip-desc';
        desc.innerHTML = markdownToHtml(baseEvent.desc);
        content.appendChild(desc);
      }

      const rail = document.createElement('div');
      rail.className = 'sceneticks';
      rail.style.setProperty('--tickCount', String(Math.max(0, tickCount | 0)));

      for (let t = 1; t <= (tickCount | 0); t++) {
        const slot = document.createElement('div');
        slot.className = 'scenetick-slot';
        slot.dataset.tick = String(t);

        const evs = tickEventsByN.get(t) || [];
        for (const entry of evs) {
          slot.appendChild(renderSceneTickEventCard(entry.ev));
        }

        rail.appendChild(slot);
      }

      content.appendChild(rail);
      chip.appendChild(content);
      return chip;
    }


    function renderEventChip(ev, opts = {}) {
      const chip = document.createElement('div');
      chip.className = 'event chip';

      if (opts.empty) chip.classList.add('empty');

      const hasDesc = !!(ev.desc && String(ev.desc).trim()) && state.showDescriptions;
      const hasHiddenDesc = !!(ev.desc && String(ev.desc).trim()) && !state.showDescriptions;

      if (hasHiddenDesc) {
        chip.addEventListener('pointerenter', (e) => {
          showDescTooltip(
            `<div class="chip-desc">${markdownToHtml(ev.desc)}</div>`,
            e.clientX,
            e.clientY
          );
        });
        chip.addEventListener('pointermove', (e) => {
          showDescTooltip(
            `<div class="chip-desc">${markdownToHtml(ev.desc)}</div>`,
            e.clientX,
            e.clientY
          );
        });
        chip.addEventListener('pointerleave', hideDescTooltip);
      }

      const content = document.createElement('div');
      content.className = 'chip-content';

      const title = document.createElement('div');
      title.className = 'chip-title';
      title.innerHTML = formatTitleWithParens(ev.title || '');
      content.appendChild(title);

      if (hasDesc) {
        const desc = document.createElement('div');
        desc.className = 'chip-desc';
        desc.innerHTML = markdownToHtml(ev.desc);
        content.appendChild(desc);
      }

      chip.appendChild(content);
      return chip;
    }


    /********************
     * Editor / Admin   *
     ********************/
    function enterEditMode() {
      state.editMode = true;
      document.getElementById('editor').classList.remove('hidden');
      document.getElementById('editor').setAttribute('aria-hidden', 'false');
      renderEditorFields();
    }
    function exitEditMode() {
      state.editMode = false;
      document.getElementById('editor').classList.add('hidden');
      document.getElementById('editor').setAttribute('aria-hidden', 'true');
      renderYearGrid();
    }

    function renderEditorUI() {
      // Static handlers within the editor
      document.getElementById('btn-exit-edit').onclick = exitEditMode;

      document.getElementById('btn-add-timeline').onclick = onAddTimeline;
      document.getElementById('btn-dup-timeline').onclick = onDupTimeline;

      document.getElementById('btn-add-story-timeline').onclick = onAddStoryTimeline;
      document.getElementById('btn-dup-story-timeline').onclick = onDupStoryTimeline;
      makeConfirmable(
        document.getElementById('btn-del-timeline'),
        () => onDelTimeline(),
        { idleText: 'Delete Timeline', confirmText: 'Confirm' }
      );


      makeConfirmable(
        document.getElementById('btn-del-story-timeline'),
        () => onDelStoryTimeline(),
        { idleText: 'Delete Story Timeline', confirmText: 'Confirm' }
      );

      document.getElementById('btn-add-sequence').onclick = onAddSequence;

      document.getElementById('btn-add-event').onclick = onAddEvent;

      // Import/Download are now here
      const fileImport = document.getElementById('file-import-editor');
      const btnDownload = document.getElementById('btn-download-editor');
      fileImport.onchange = onImportTimelinesJS;
      btnDownload.onclick = downloadTimelinesJS;
    }

    function renderEditorFields() {
      renderTimelineList();
      renderStoryTimelineList();

      // Default selection if none
      const hasTimelineSel = !!state.selectedTimelineId && state.timelines.some(t => t.id === state.selectedTimelineId);
      const hasStorySel = !!state.selectedStoryTimelineId && state.storyTimelines.some(st => st.id === state.selectedStoryTimelineId);

      if (!hasTimelineSel && !hasStorySel) {
        if (state.timelines.length) {
          state.selectedEditorKind = 'timeline';
          state.selectedTimelineId = state.timelines[0].id;
        } else if (state.storyTimelines.length) {
          state.selectedEditorKind = 'story';
          state.selectedStoryTimelineId = state.storyTimelines[0].id;
        } else {
          state.selectedEditorKind = 'timeline';
          state.selectedTimelineId = null;
          state.selectedStoryTimelineId = null;
        }
      } else if (hasTimelineSel && !hasStorySel) {
        state.selectedEditorKind = 'timeline';
      } else if (!hasTimelineSel && hasStorySel) {
        state.selectedEditorKind = 'story';
      }

      renderTimelineList();
      renderStoryTimelineList();

      // Render details for selected
      renderTimelineEditor();
    }


    function getSelectedTimeline() {
      if (state.selectedEditorKind !== 'timeline') return null;
      return state.timelines.find(t => t.id === state.selectedTimelineId) || null;
    }

    function getSelectedStoryTimeline() {
      if (state.selectedEditorKind !== 'story') return null;
      return state.storyTimelines.find(st => st.id === state.selectedStoryTimelineId) || null;
    }


    function sortTimelineEvents(tl) {
      if (!tl || !Array.isArray(tl.events)) return;

      const ctx = { timelines: state.timelines, cache: new Map(), stack: [] };
      const anchorYear = resolveTimelineAnchorYear(tl, ctx);

      const safeAbsYearAndTick = (ev) => {
        try {
          const raw = String(ev.year || '').trim();
          if (!raw) return { ok: false, year: Number.POSITIVE_INFINITY, tick: Number.POSITIVE_INFINITY };

          const { base, tick } = splitBaseAndTick(raw);
          const absYear = parseYearToken(base, anchorYear, ctx).year;

          return {
            ok: true,
            year: absYear,
            tick: Number.isFinite(tick) ? tick : 0
          };
        } catch {
          return { ok: false, year: Number.POSITIVE_INFINITY, tick: Number.POSITIVE_INFINITY };
        }
      };

      tl.events = tl.events
        .map((ev, idx) => ({ ev, idx }))
        .sort((A, B) => {
          const a = safeAbsYearAndTick(A.ev);
          const b = safeAbsYearAndTick(B.ev);

          // 1) Absolute year (invalid years sort last)
          if (a.year !== b.year) return a.year - b.year;

          // 2) Tick number within the same year (0 = base events)
          if (a.tick !== b.tick) return a.tick - b.tick;

          // 3) Title (case-insensitive; empty titles last-ish)
          const at = String(A.ev.title || '').trim().toLowerCase();
          const bt = String(B.ev.title || '').trim().toLowerCase();

          const aEmpty = at === '';
          const bEmpty = bt === '';
          if (aEmpty !== bEmpty) return aEmpty ? 1 : -1;

          if (at !== bt) return at.localeCompare(bt);

          // 4) Stable fallback to original order
          return A.idx - B.idx;
        })
        .map(x => x.ev);
    }


    function renderTimelineEditor() {
      // Switch the editor panel based on what is selected (timeline vs story timeline)
      if (state.selectedEditorKind === 'story') {
        renderStoryTimelineEditor();
        return;
      }

      const tl = getSelectedTimeline();

      const normalWrap = document.getElementById('timeline-editor-normal');
      const storyWrap = document.getElementById('timeline-editor-story');
      if (normalWrap) { normalWrap.classList.remove('hidden'); normalWrap.setAttribute('aria-hidden', 'false'); }
      if (storyWrap) { storyWrap.classList.add('hidden'); storyWrap.setAttribute('aria-hidden', 'true'); }

      const titleEl = document.getElementById('tl-title');
      const yearEl = document.getElementById('tl-year');
      const descEl = document.getElementById('tl-desc');

      // Weâ€™re removing images from admin â€“ hide/disable if the element still exists in the DOM
      const imageEl = document.getElementById('tl-image');

      const colorEl = document.getElementById('tl-color');
      const tbody = document.getElementById('events-body');
      const sortBtn = document.getElementById('btn-sort-events');

      if (sortBtn) {
        sortBtn.disabled = !tl;
        sortBtn.onclick = () => {
          if (!tl) return;
          sortTimelineEvents(tl);
          renderTimelineEditor();
          renderYearGrid();
        };
      }

      // Hide timeline image field in admin (if still present)
      if (imageEl) {
        const label = imageEl.closest('label');
        if (label) label.style.display = 'none';
        imageEl.value = '';
        imageEl.disabled = true;
      }

      if (!tl) {
        if (titleEl) titleEl.value = '';
        if (yearEl) yearEl.value = '';
        if (descEl) descEl.value = '';
        if (colorEl) colorEl.value = '#cccccc';
        if (tbody) tbody.innerHTML = '<tr><td colspan="4" class="muted">No timeline selected</td></tr>';
        return;
      }

      // Ensure fields exist (backwards compatible)
      tl.year = (tl.year === undefined || tl.year === null || String(tl.year).trim() === '')
        ? '2000'
        : String(tl.year).trim();

      tl.description = String(tl.description || '');

      // Keep tl.image in data for backwards compatibility, but admin no longer edits it
      if (tl.image !== undefined) tl.image = String(tl.image || '');

      tl.events = Array.isArray(tl.events) ? tl.events : [];
      for (const ev of tl.events) {
        ev.year = String(ev.year || '').trim();
        ev.title = String(ev.title || '');
        ev.desc = String(ev.desc || '');
        // Keep ev.image in data for backwards compatibility, but admin no longer edits it
        if (ev.image !== undefined) ev.image = String(ev.image || '');
      }

      if (titleEl) titleEl.value = tl.title || '';
      if (yearEl) yearEl.value = String(tl.year);
      if (descEl) descEl.value = tl.description;
      if (colorEl) colorEl.value = tl.color || '#cccccc';

      if (titleEl) {
        titleEl.oninput = debounce(() => {
          tl.title = titleEl.value.trim();
          renderTimelineList();
          renderToggleBar();
          renderYearGrid();
        }, 150);
      }

      if (yearEl) {
        yearEl.oninput = debounce(() => {
          tl.year = yearEl.value.trim();
          renderYearGrid();
        }, 150);
      }

      if (descEl) {
        descEl.oninput = debounce(() => {
          tl.description = descEl.value;
          renderYearGrid();
        }, 150);
      }

      if (colorEl) {
        colorEl.oninput = debounce(() => {
          tl.color = colorEl.value;
          renderTimelineList();
          renderToggleBar();
          renderYearGrid();
        }, 150);
      }

      // --- Events table (NO image column) ---
      if (!tbody) return;
      tbody.innerHTML = '';

      for (let i = 0; i < tl.events.length; i++) {
        const ev = tl.events[i];

        const tr = document.createElement('tr');

        // Year
        const tdYear = document.createElement('td');
        const inYear = document.createElement('input');
        inYear.type = 'text';
        inYear.placeholder = '1994 | 300bc | 20ya | 20yb';
        inYear.value = ev.year || '';
        inYear.oninput = debounce(() => {
          ev.year = inYear.value.trim();
          try {
            const ctx = { timelines: state.timelines, cache: new Map(), stack: [] };
            const anchorYear = resolveTimelineAnchorYear(tl, ctx);
            const { base } = splitBaseAndTick(ev.year);
            parseYearToken(base, anchorYear, ctx);
            inYear.classList.remove('invalid');
            renderYearGrid();
          } catch {
            inYear.classList.add('invalid');
          }
        }, 150);
        tdYear.appendChild(inYear);

        // Title
        const tdTitle = document.createElement('td');
        const inTitle = document.createElement('input');
        inTitle.type = 'text';
        inTitle.placeholder = 'Event title (optional)';
        inTitle.value = ev.title || '';
        inTitle.oninput = debounce(() => {
          ev.title = inTitle.value.trim();
          renderYearGrid();
        }, 150);
        tdTitle.appendChild(inTitle);

        // Desc
        const tdDesc = document.createElement('td');
        const inDesc = document.createElement('textarea');
        inDesc.placeholder = 'Description (Markdown supported)';
        inDesc.value = ev.desc || '';
        inDesc.rows = Math.max(3, Math.min(10, (inDesc.value.split('\n').length || 1)));
        inDesc.style.width = '300px';
        inDesc.addEventListener('input', () => {
          inDesc.style.height = 'auto';
          inDesc.style.height = (inDesc.scrollHeight) + 'px';
        });
        inDesc.oninput = debounce(() => {
          ev.desc = inDesc.value;
          renderYearGrid();
        }, 150);
        requestAnimationFrame(() => {
          inDesc.style.height = 'auto';
          inDesc.style.height = (inDesc.scrollHeight) + 'px';
        });
        tdDesc.appendChild(inDesc);

        // Delete
        const tdDel = document.createElement('td');
        const btnDel = document.createElement('button');
        btnDel.className = 'btn danger';
        btnDel.textContent = 'Delete';
        makeConfirmable(btnDel, () => {
          tl.events.splice(i, 1);
          renderTimelineEditor();
          renderYearGrid();
        }, { idleText: 'Delete', confirmText: 'Confirm' });
        tdDel.appendChild(btnDel);

        tr.appendChild(tdYear);
        tr.appendChild(tdTitle);
        tr.appendChild(tdDesc);
        tr.appendChild(tdDel);

        tbody.appendChild(tr);
      }

      if (!tl.events.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 4;
        td.className = 'muted';
        td.textContent = 'No events yet.';
        tr.appendChild(td);
        tbody.appendChild(tr);
      }
    }
    function renderStoryTimelineEditor() {
      const normalWrap = document.getElementById('timeline-editor-normal');
      const storyWrap = document.getElementById('timeline-editor-story');

      if (normalWrap) { normalWrap.classList.add('hidden'); normalWrap.setAttribute('aria-hidden', 'true'); }
      if (storyWrap) { storyWrap.classList.remove('hidden'); storyWrap.setAttribute('aria-hidden', 'false'); }

      const st = getSelectedStoryTimeline();

      const titleEl = document.getElementById('st-title');
      const tbody = document.getElementById('sequences-body');
      const addBtn = document.getElementById('btn-add-sequence');
      const delBtn = document.getElementById('btn-del-story-timeline');

      if (addBtn) addBtn.disabled = !st;
      if (delBtn) delBtn.disabled = !st;

      if (!st) {
        if (titleEl) titleEl.value = '';
        if (tbody) tbody.innerHTML = '<tr><td colspan="3" class="muted">No story timeline selected</td></tr>';
        return;
      }

      st.title = String(st.title || '(Story)');
      st.sequences = Array.isArray(st.sequences) ? st.sequences : [];

      if (titleEl) {
        titleEl.value = st.title || '';
        titleEl.oninput = debounce(() => {
          st.title = titleEl.value.trim() || '(Story)';
          renderStoryTimelineList();
          renderToggleBar();
          renderYearGrid();
        }, 150);
      }

      st.sequences.sort((a, b) => (a.seq || 0) - (b.seq || 0));

      if (!tbody) return;
      tbody.innerHTML = '';

      for (let i = 0; i < st.sequences.length; i++) {
        const seq = st.sequences[i];
        seq.seq = Number.isFinite(+seq.seq) ? +seq.seq : 0;
        seq.title = String(seq.title || '');
        // seq.desc is deprecated/ignored
        seq.map = String(seq.map || '');

        const tr = document.createElement('tr');

        // Column 1: Number + Title (no Description)
        const tdMeta = document.createElement('td');

        const rowNum = document.createElement('div');
        rowNum.textContent = 'Number: ';
        const inSeq = document.createElement('input');
        inSeq.type = 'number';
        inSeq.step = '1';
        inSeq.value = String(seq.seq || 0);
        inSeq.oninput = debounce(() => {
          seq.seq = parseInt(inSeq.value || '0', 10) || 0;
          renderStoryTimelineEditor();
          renderYearGrid();
        }, 150);
        rowNum.appendChild(inSeq);

        const rowTitle = document.createElement('div');
        rowTitle.textContent = 'Title: ';
        const inTitle = document.createElement('input');
        inTitle.type = 'text';
        inTitle.placeholder = 'Sequence title (optional)';
        inTitle.value = seq.title || '';
        inTitle.oninput = debounce(() => {
          seq.title = inTitle.value;
          renderYearGrid();
        }, 150);
        rowTitle.appendChild(inTitle);

        tdMeta.appendChild(rowNum);
        tdMeta.appendChild(rowTitle);

        // Column 2: Map
        const tdMap = document.createElement('td');
        const inMap = document.createElement('textarea');
        inMap.placeholder =
          `01: The first things that happened.
- Kalos 0ya.01
- Kalos 0ya.02

02: A later moment.
- Kalos 0ya.03 Flashback`;
        inMap.value = seq.map || '';
        inMap.rows = Math.max(6, Math.min(20, (inMap.value.split('\n').length || 1)));
        inMap.style.width = '340px';
        inMap.style.height = '246px';
        inMap.addEventListener('input', () => {
          inMap.style.height = 'auto';
          inMap.style.height = (inMap.scrollHeight) + 'px';
        });
        inMap.oninput = debounce(() => {
          seq.map = inMap.value;
          renderYearGrid();
        }, 150);
        requestAnimationFrame(() => {
          inMap.style.height = 'auto';
          inMap.style.height = (inMap.scrollHeight) + 'px';
        });
        tdMap.appendChild(inMap);

        // Column 3: Delete
        const tdDel = document.createElement('td');
        const btnDel = document.createElement('button');
        btnDel.className = 'btn danger';
        btnDel.textContent = 'Delete';
        makeConfirmable(btnDel, () => {
          st.sequences.splice(i, 1);
          renderStoryTimelineEditor();
          renderYearGrid();
        }, { idleText: 'Delete', confirmText: 'Confirm' });
        tdDel.appendChild(btnDel);

        tr.appendChild(tdMeta);
        tr.appendChild(tdMap);
        tr.appendChild(tdDel);
        tbody.appendChild(tr);
      }

      if (!st.sequences.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 3;
        td.className = 'muted';
        td.textContent = 'No sequences yet.';
        tr.appendChild(td);
        tbody.appendChild(tr);
      }
    }


    function onAddStoryTimeline() {
      const id = 'st_' + Math.random().toString(36).slice(2, 8);
      const st = { id, title: 'New Story Timeline', sequences: [] };
      state.storyTimelines.push(st);
      state.selectedEditorKind = 'story';
      state.selectedStoryTimelineId = id;
      state.selectedTimelineId = null;

      renderStoryTimelineList();
      renderToggleBar();
      renderYearGrid();
      renderTimelineEditor();
    }

    function onDupStoryTimeline() {
      const st = getSelectedStoryTimeline();
      if (!st) return;
      const copy = JSON.parse(JSON.stringify(st));
      copy.id = 'st_' + Math.random().toString(36).slice(2, 8);
      copy.title = (st.title || '(Story)') + ' (copy)';
      copy.sequences = Array.isArray(copy.sequences) ? copy.sequences : [];

      state.storyTimelines.push(copy);
      state.selectedEditorKind = 'story';
      state.selectedStoryTimelineId = copy.id;
      state.selectedTimelineId = null;

      renderStoryTimelineList();
      renderToggleBar();
      renderYearGrid();
      renderTimelineEditor();
    }

    function onDelStoryTimeline() {
      const st = getSelectedStoryTimeline();
      if (!st) return;

      const idx = state.storyTimelines.findIndex(x => x.id === st.id);
      if (idx >= 0) state.storyTimelines.splice(idx, 1);

      if (state.storyTimelines.length) {
        state.selectedEditorKind = 'story';
        state.selectedStoryTimelineId = state.storyTimelines[0].id;
        state.selectedTimelineId = null;
      } else if (state.timelines.length) {
        state.selectedEditorKind = 'timeline';
        state.selectedTimelineId = state.timelines[0].id;
        state.selectedStoryTimelineId = null;
      } else {
        state.selectedEditorKind = 'timeline';
        state.selectedTimelineId = null;
        state.selectedStoryTimelineId = null;
      }

      renderStoryTimelineList();
      renderToggleBar();
      renderYearGrid();
      renderTimelineEditor();
    }

    function onAddSequence() {
      const st = getSelectedStoryTimeline();
      if (!st) return;

      st.sequences = Array.isArray(st.sequences) ? st.sequences : [];
      const nextSeq =
        st.sequences.length
          ? Math.max(...st.sequences.map(s => +s.seq || 0)) + 1
          : 1;

      st.sequences.push({
        seq: nextSeq,
        title: '',
        map: ''
      });

      renderStoryTimelineEditor();
      renderYearGrid();
    }

    function onAddTimeline() {
      const id = 'tl_' + Math.random().toString(36).slice(2, 8);
      const tl = {
        id,
        title: 'New Timeline',
        color: '#8aa',
        year: '2000',
        description: '',
        events: []
      };

      state.timelines.push(tl);
      state.selectedEditorKind = 'timeline';
      state.selectedTimelineId = id;
      state.selectedStoryTimelineId = null;

      renderTimelineList();
      renderToggleBar();
      renderYearGrid();
      renderTimelineEditor();
    }
    function onDupTimeline() {
      const tl = getSelectedTimeline();
      if (!tl) return;

      const copy = JSON.parse(JSON.stringify(tl));
      copy.id = 'tl_' + Math.random().toString(36).slice(2, 8);
      copy.title = (tl.title || '(Untitled)') + ' (copy)';

      // Strip any legacy image fields that might exist in older data
      if ('image' in copy) delete copy.image;
      copy.events = Array.isArray(copy.events) ? copy.events.map(ev => {
        if (ev && typeof ev === 'object' && 'image' in ev) delete ev.image;
        return ev;
      }) : [];

      state.timelines.push(copy);
      state.selectedEditorKind = 'timeline';
      state.selectedTimelineId = copy.id;
      state.selectedStoryTimelineId = null;

      renderTimelineList();
      renderToggleBar();
      renderYearGrid();
      renderTimelineEditor();
    }
    function onDelTimeline() {
      const tl = getSelectedTimeline();
      if (!tl) return;

      const idx = state.timelines.findIndex(t => t.id === tl.id);
      if (idx >= 0) state.timelines.splice(idx, 1);

      if (state.timelines.length) {
        state.selectedEditorKind = 'timeline';
        state.selectedTimelineId = state.timelines[0].id;
        state.selectedStoryTimelineId = null;
      } else if (state.storyTimelines.length) {
        state.selectedEditorKind = 'story';
        state.selectedStoryTimelineId = state.storyTimelines[0].id;
        state.selectedTimelineId = null;
      } else {
        state.selectedEditorKind = 'timeline';
        state.selectedTimelineId = null;
        state.selectedStoryTimelineId = null;
      }

      renderTimelineList();
      renderStoryTimelineList();
      renderToggleBar();
      renderYearGrid();
      renderTimelineEditor();
    }
    function onAddEvent() {
      const tl = getSelectedTimeline();
      if (!tl) return;

      tl.events.push({ year: '1994', title: '', desc: '' });
      renderTimelineEditor();
      renderYearGrid();
    }

    const debounce = (fn, ms = 200) => {
      let t = null;
      return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
    };

    /**********************
     * Import / Download  *
     **********************/
    async function onImportTimelinesJS(evt) {
      const file = evt.target.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        // For local file use, we just eval into window.TIMELINES_DEFAULT safely via a Blob
        const blobUrl = URL.createObjectURL(new Blob([text], { type: 'text/javascript' }));
        const el = document.createElement('script');
        el.src = blobUrl;
        el.onload = () => {
          URL.revokeObjectURL(blobUrl);
          state.timelines = normalizeTimelines(window.TIMELINES_DEFAULT?.timelines);
          state.storyTimelines = normalizeStoryTimelines(window.TIMELINES_DEFAULT?.storyTimelines);
          state.selectedTimelineId = state.timelines[0]?.id || null;
          state.selectedStoryTimelineId = null;
          state.selectedEditorKind = state.selectedTimelineId ? 'timeline' : (state.storyTimelines[0]?.id ? 'story' : 'timeline');
          renderEditorFields();
          renderToggleBar();
          renderYearGrid();
        };
        el.onerror = (e) => {
          URL.revokeObjectURL(blobUrl);
          alert('Import failed.');
          console.error(e);
        };
        document.head.appendChild(el);
      } catch (err) {
        alert('Import failed: ' + err.message);
        console.error(err);
      } finally {
        evt.target.value = '';
      }
    }

    function stripImageFieldsFromTimelines(timelines) {
      const src = Array.isArray(timelines) ? timelines : [];

      return src.map(tl => {
        const out = { ...tl };

        // Remove timeline-level legacy image field
        if ('image' in out) delete out.image;

        // Events
        out.events = Array.isArray(out.events)
          ? out.events.map(ev => {
            const e = { ...ev };
            if ('image' in e) delete e.image; // Remove event-level legacy image field
            return e;
          })
          : [];

        return out;
      });
    }

    function downloadTimelinesJS() {
      const code = generateTimelinesModule(state.timelines);
      const blob = new Blob([code], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = 'story-timelines.js';
      document.body.appendChild(a);
      a.click();
      a.remove();

      // Revoke on next tick so the browser has time to start the download
      setTimeout(() => URL.revokeObjectURL(url), 0);
    }

    function generateTimelinesModule(timelines) {
      const cleanTimelines = stripImageFieldsFromTimelines(timelines);

      // Also strip any legacy "desc" on story sequences if youâ€™re trying to keep exports clean
      const cleanStory = (state.storyTimelines || []).map(st => ({
        ...st,
        sequences: Array.isArray(st.sequences)
          ? st.sequences.map(seq => {
            const s = { ...seq };
            if ('desc' in s) delete s.desc; // optional cleanup
            return s;
          })
          : []
      }));

      const safeTimelines = JSON.stringify(cleanTimelines, null, 2);
      const safeStory = JSON.stringify(cleanStory, null, 2);

      return `// Generated by Year Timelines
window.TIMELINES_DEFAULT = {
  timelines: ${safeTimelines},
  storyTimelines: ${safeStory}
};
`;
    }

    function normalizeTimelines(arr) {
      const timelines = Array.isArray(arr) ? arr : [];

      for (const tl of timelines) {
        tl.id ||= 'tl_' + Math.random().toString(36).slice(2, 8);
        tl.title ||= '(Untitled)';
        tl.color ||= '#8aa';

        tl.description = String(tl.description || '');

        // âœ… Kill legacy timeline image key if it exists
        if ('image' in tl) delete tl.image;

        // Keep year as a token string
        if (tl.year === undefined || tl.year === null || String(tl.year).trim() === '') {
          tl.year = '2000';
        } else {
          tl.year = String(tl.year).trim();
        }

        tl.events = Array.isArray(tl.events) ? tl.events : [];
        for (const ev of tl.events) {
          ev.year = String(ev.year || '').trim();
          ev.title = String(ev.title || '');
          ev.desc = String(ev.desc || '');

          // âœ… Kill legacy event image key if it exists
          if ('image' in ev) delete ev.image;
        }
      }

      return timelines;
    }



    /************
     * Boot     *
     ************/
    function initState(initialModule) {
      state.timelines = normalizeTimelines(initialModule?.timelines);
      state.storyTimelines = normalizeStoryTimelines(initialModule?.storyTimelines);

      if (state.timelines.length) {
        state.selectedEditorKind = 'timeline';
        state.selectedTimelineId = state.timelines[0].id;
        state.selectedStoryTimelineId = null;
      } else if (state.storyTimelines.length) {
        state.selectedEditorKind = 'story';
        state.selectedStoryTimelineId = state.storyTimelines[0].id;
        state.selectedTimelineId = null;
      } else {
        state.selectedEditorKind = 'timeline';
        state.selectedTimelineId = null;
        state.selectedStoryTimelineId = null;
      }

      state.theme = 'light';
    }
    initState(DATA_DEFAULT);
    renderApp();
  </script>
</body>

</html>