<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Pokemon Timelines</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Reuse your existing styles; this file only provides structure. -->
  <link rel="stylesheet" href="story-styles.css" />
</head>

<body data-theme="light">
  <header class="app-header">
    <div class="left">
      <h1 class="app-title">Pokemon Timelines</h1>
    </div>
    <div class="right controls">
      <button id="btn-theme" class="btn">Toggle Theme</button>
      <button id="btn-edit" class="btn primary">Edit</button>
      <!-- Import/Download moved into the editor header -->
    </div>
  </header>

  <main class="app-main">
    <!-- Editor (hidden by default) -->
    <aside id="editor" class="panel editor hidden" aria-hidden="true">
      <div class="editor-header">
        <h2>Editor</h2>
        <div class="row gap">
          <label class="btn">
            Import .js
            <input id="file-import-editor" type="file" accept=".js" hidden />
          </label>
          <button id="btn-download-editor" class="btn">Download .js</button>
          <button id="btn-exit-edit" class="btn">Done</button>
        </div>
      </div>

      <div class="editor-body">
        <section>
          <div class="timeline-editor-head">
            <h3>Timelines</h3>
            <div class="row gap">
              <button id="btn-add-timeline" class="btn">+ Add Timeline</button>
              <button id="btn-dup-timeline" class="btn">Duplicate</button>
            </div>
          </div>
          <div id="timeline-list" class="listbox" role="listbox" aria-label="Timelines"></div>

          <div class="timeline-editor-head" style="margin-top:1rem;">
            <h3>Story Timelines</h3>
            <div class="row gap">
              <button id="btn-add-story-timeline" class="btn">+ Add Story Timeline</button>
              <button id="btn-dup-story-timeline" class="btn">Duplicate</button>
            </div>
          </div>
          <div id="story-timeline-list" class="listbox" role="listbox" aria-label="Story Timelines"></div>
        </section>

        <section id="timeline-editor" class="stack gap">
          <!-- Normal timeline editor -->
          <div id="timeline-editor-normal" class="stack gap">
            <div class="timeline-editor-head">
              <h3>Timeline Details</h3>
              <div class="row gap">
                <button id="btn-add-event" class="btn">+ Add Event</button>
                <button id="btn-del-timeline" class="btn danger">Delete Timeline</button>
              </div>
            </div>
            <div class="timeline-editor-body">
              <div class="column between">
                <div>
                  <label>Title
                    <input id="tl-title" type="text" placeholder="Timeline title" />
                  </label>

                  <label>Anchor Year
                    <input id="tl-year" type="text" step="1" placeholder="2000 | 5aKANTO" />
                  </label>

                  <label>Color (optional)
                    <input id="tl-color" type="color" />
                  </label>
                </div>
                <div>
                  <label style="flex:1 1 100%;">Timeline Description
                    <textarea id="tl-desc" rows="3"
                      placeholder="Shown on the anchor event (Markdown supported)"></textarea>
                  </label>

                  <label style="flex:1 1 100%;">Timeline Image (slug/subpath/url)
                    <input id="tl-image" type="text" placeholder="slug.webp | folder/slug.webp | https://…" />
                  </label>
                </div>

                <button id="btn-sort-events" class="btn">Sort</button>
              </div>

              <table class="events-table">
                <thead>
                  <tr>
                    <th style="width:10rem">Year</th>
                    <th style="width:16rem">Title</th>
                    <th>Description</th>
                    <th style="width:18rem">Image (slug/subpath/url)</th>
                    <th style="width:5rem"></th>
                  </tr>
                </thead>
                <tbody id="events-body"></tbody>
              </table>
              <div class="muted small">Year accepts <code>####</code> or <code>####bc</code> (e.g., <code>1994</code>,
                <code>3000000bc</code>).</div>
            </div>
          </div>

          <!-- Story timeline editor -->
          <div id="timeline-editor-story" class="stack gap hidden" aria-hidden="true">
            <div class="timeline-editor-head">
              <h3>Story Timeline Details</h3>
              <div class="row gap">
                <button id="btn-add-sequence" class="btn">+ Add Sequence</button>
                <button id="btn-del-story-timeline" class="btn danger">Delete Story Timeline</button>
              </div>
            </div>

            <div class="timeline-editor-body">
              <div class="column between">
                <div>
                  <label>Title
                    <input id="st-title" type="text" placeholder="Story timeline title" />
                  </label>
                </div>
              </div>

              <table class="events-table">
                <thead>
                  <tr>
                    <th style="width:6rem">Seq</th>
                    <th style="width:14rem">Title</th>
                    <th>Description</th>
                    <th style="width:20rem">Map</th>
                    <th style="width:5rem"></th>
                  </tr>
                </thead>
                <tbody id="sequences-body"></tbody>
              </table>
              <div class="muted small">
                Map accepts multiple page blocks. Example:<br>
                <code>01</code><br>
                <code>- Kalos 0ya.01</code><br>
                <code>- Kalos 0ya.02 Flashback</code>
              </div>
            </div>
          </div>
        </section>
      </div>
    </aside>

    <!-- Timeline Grid -->
    <section class="viewport">
      <div id="grid" class="year-grid" role="grid" aria-label="Year timelines grid"></div>
    </section>

    <section class="explanation">
      <h2>About This Timeline</h2>
      <p>This tool helps you visualize multiple timelines of events, such as the various regions and story arcs
        within the Pokémon universe. You can add timelines, define their anchor years, and populate them with events.
        The grid view allows you to see how these timelines align chronologically.</p>
      <p>Timelines anchor dates can be connected to other timelines. For example, "3aKANTO" means 3 years after the
        KANTO timeline's anchor year.</p>
      <p>Events within a timeline can be given an explicit year (eg: 1996 or 2000bc), or a "years ago" date (eg: 50ya)
        which places the event relative to the timeline's anchor year when the YA date is less than 1000, and places it
        relative to the year 2000 if the YA date is 1000 or more.</p>
    </section>
  </main>

  <!-- Your data file as a classic script (global) -->
  <script src="./story-timelines.js"></script>

  <!-- Main logic -->
  <script type="module">
    const DATA_DEFAULT = window.TIMELINES_DEFAULT;

    /***************
     * Data Model  *
     ***************/
    /**
     * Data shape:
     * window.TIMELINES_DEFAULT = {
     *   timelines: [
     *     { id, title, color?, events: [{year:"1994"| "3000000bc", title?, desc?, image?, category?}] }
     *   ]
     * }
     */
    const state = {
      timelines: [],
      editMode: false,
      selectedTimelineId: null,
      selectedStoryTimelineId: null,
      selectedEditorKind: "timeline",
      theme: 'light',
      hiddenTimelineIds: new Set(),
      showDescriptions: false,
      showImages: true,
      storyTimelines: [],
      hiddenStoryTimelineIds: new Set(),
    };

    function moveTimeline(fromIndex, toIndex) {
      if (fromIndex === toIndex) return;
      if (fromIndex < 0 || toIndex < 0) return;
      if (fromIndex >= state.timelines.length || toIndex >= state.timelines.length) return;

      const [item] = state.timelines.splice(fromIndex, 1);
      state.timelines.splice(toIndex, 0, item);
    }

    function indexOfTimelineId(id) {
      return state.timelines.findIndex(t => t.id === id);
    }

    function normalizeTimelineKey(name) {
      return String(name || '').trim().toLowerCase();
    }

    function getTimelineByName(name, timelines) {
      const key = normalizeTimelineKey(name);
      return (timelines || []).find(t => normalizeTimelineKey(t.title) === key) || null;
    }

    /**
     * Resolve a timeline's anchor year to an absolute numeric year.
     * Supports:
     *  - 1999
     *  - "1999"
     *  - "5aKANTO" (relative to another timeline anchor)
     */
    function resolveTimelineAnchorYear(tl, ctx) {
      const timelines = ctx?.timelines || (typeof state !== 'undefined' ? state.timelines : []) || [];
      const cache = ctx?.cache || null;
      const stack = ctx?.stack || [];

      if (!tl) return 2000;

      if (cache && cache.has(tl.id)) return cache.get(tl.id);

      // Cycle protection
      if (stack.includes(tl.id)) {
        throw new Error(`Circular anchor reference detected: ${stack.join(' -> ')} -> ${tl.id}`);
      }
      stack.push(tl.id);

      const raw = tl.year;

      let out;
      if (typeof raw === 'number' && Number.isFinite(raw)) {
        out = raw;
      } else if (typeof raw === 'string' && raw.trim() !== '') {
        // Note: baseYear is irrelevant for absolute years,
        // but parseYearToken also handles "ya" if someone ever uses it in anchor years.
        out = parseYearToken(raw, 2000, { timelines, cache, stack }).year;
      } else {
        out = 2000;
      }

      stack.pop();
      if (cache) cache.set(tl.id, out);
      return out;
    }

    function normalizeStoryTimelines(arr) {
      const out = Array.isArray(arr) ? arr : [];
      for (const st of out) {
        st.id ||= 'st_' + Math.random().toString(36).slice(2, 8);
        st.title ||= '(Untitled Story Timeline)';
        st.sequences = Array.isArray(st.sequences) ? st.sequences : [];
        for (const seq of st.sequences) {
          seq.seq ||= 0; // numeric sort key
          seq.title = String(seq.title || '');
          seq.desc = String(seq.desc || '');
          // text block that contains page mapping lines
          seq.map = String(seq.map || '');
        }
      }
      return out;
    }

    /**
     * Parse the mapping text from a sequence.
     * Supported line formats (leading/trailing whitespace ok):
     *  - "01"
     *  - "- Kalos 0ya.02 Flashback"
     *  - "- Kalos 1964.03"
     *
     * Output:
     *  { page: "01", refs: [{ timelineName, token, category }] }
     */
    function parseSequenceMapBlocks(mapText) {
      const lines = String(mapText || '').replace(/\r\n/g, '\n').split('\n');

      /** @type {Array<{page:string|null, refs:Array<{timelineName:string, token:string, category:string}>}>} */
      const blocks = [];

      let current = null;

      const pushCurrent = () => {
        if (!current) return;
        // only keep if it has a page and at least 1 ref
        if (current.page && current.refs.length) blocks.push(current);
        current = null;
      };

      for (const rawLine of lines) {
        const line = rawLine.trim();
        if (!line) continue;

        // Page number line: digits only
        if (/^\d+$/.test(line)) {
          // finish previous
          pushCurrent();

          // start new
          current = { page: line.padStart(2, '0'), refs: [] };
          continue;
        }

        // Ref line: "- TimelineName token [category...]"
        const m = line.match(/^-+\s*(.+?)\s+([^\s]+)\s*(.*)$/);
        if (!m) continue;

        // If someone forgets to put a page number first, ignore refs until a page appears
        if (!current) continue;

        const timelineName = (m[1] || '').trim();
        const token = (m[2] || '').trim();
        const category = (m[3] || '').trim();

        if (!timelineName || !token) continue;
        current.refs.push({ timelineName, token, category });
      }

      pushCurrent();
      return blocks;
    }
    /**
     * Resolve a story ref ("Kalos 0ya.02") into:
     *  { absYear, tick, timelineId? }
     */
    function resolveStoryRef(ref, ctx) {
      const timelines = ctx?.timelines || state.timelines || [];
      const tl = getTimelineByName(ref.timelineName, timelines);
      if (!tl) throw new Error(`Story ref timeline not found: "${ref.timelineName}"`);

      const anchorYear = resolveTimelineAnchorYear(tl, ctx);
      const { base, tick } = splitBaseAndTick(ref.token);
      const absYear = parseYearToken(base, anchorYear, ctx).year;

      return { absYear, tick: tick || 0, timelineId: tl.id };
    }

    function renderStoryPageBlock(page, tickCount) {
      const el = document.createElement('div');
      el.className = 'story-page';

      const head = document.createElement('div');
      head.className = 'story-page-head';
      head.textContent = page.label; // "01" or "01 (Flashback)"
      el.appendChild(head);

      if (page.descHtml) {
        const desc = document.createElement('div');
        desc.className = 'story-page-desc';
        desc.innerHTML = page.descHtml;
        el.appendChild(desc);
      }

      const rail = document.createElement('div');
      rail.className = 'story-ticks';
      rail.style.setProperty('--tickCount', String(Math.max(0, tickCount | 0)));

      // slots 1..N (gaps visible)
      for (let t = 1; t <= (tickCount | 0); t++) {
        const slot = document.createElement('div');
        slot.className = 'story-tick';
        slot.dataset.tick = String(t);

        // marker range
        if (t >= page.fromTick && t <= page.toTick) slot.classList.add('on');

        rail.appendChild(slot);
      }

      el.appendChild(rail);
      return el;
    }

    function renderStoryYearCellPages(cell, pages, tickCount) {
      // Render each page as its own block inside this year cell
      // (You asked: "one block per page, with ticks inside that")
      for (const p of pages) {
        cell.appendChild(renderStoryPageBlock(p, tickCount));
      }
    }

    /**
     * Build per-year story overlays to render as spans above tick rails.
     * Returns: Map<absYear, Array<{fromTick,toTick,label}>>
     */
    function buildStoryPagesByYear(storyTimeline, maxTickByYear, ctx) {
      const out = new Map();

      const sequences = (storyTimeline.sequences || [])
        .slice()
        .sort((a, b) => (a.seq || 0) - (b.seq || 0));

      for (const seq of sequences) {
        // NEW: parse multiple page blocks inside the sequence map text
        const blocks = parseSequenceMapBlocks(seq.map);

        // Description: use ONLY seq.desc (not title)
        const desc = String(seq.desc || '').trim();
        const descHtml = desc ? markdownToHtml(desc) : '';

        for (const block of blocks) {
          const pageNum = block.page || '??';

          // group refs by absYear (per page)
          const byYear = new Map();

          for (const r of block.refs) {
            try {
              const rr = resolveStoryRef(r, ctx);
              if (!byYear.has(rr.absYear)) byYear.set(rr.absYear, []);
              byYear.get(rr.absYear).push({ ...rr, category: r.category || '' });
            } catch {
              // ignore bad refs for now
            }
          }

          for (const [absYear, list] of byYear.entries()) {
            const ticks = list
              .map(x => x.tick || 0)
              .filter(t => t > 0)
              .sort((a, b) => a - b);

            if (!ticks.length) continue;

            const fromTick = ticks[0];
            const toTick = ticks[ticks.length - 1];

            // Category suffix appended to page number in brackets
            const cat = (list.find(x => x.category && x.category.trim())?.category || '').trim();
            const label = cat ? `${pageNum} (${cat})` : `${pageNum}`;

            const tickCount = maxTickByYear.get(absYear) || 0;
            const clampedFrom = Math.max(1, Math.min(fromTick, tickCount || fromTick));
            const clampedTo = Math.max(clampedFrom, Math.min(toTick, tickCount || toTick));

            if (!out.has(absYear)) out.set(absYear, []);
            out.get(absYear).push({
              pageNum,
              label,
              descHtml,
              fromTick: clampedFrom,
              toTick: clampedTo
            });
          }
        }
      }

      return out;
    }

    /**********************
     * Utility / Parsing  *
     **********************/

    function splitBaseAndTick(token) {
      const raw = String(token || '').trim();
      // Match: <base>.<tick> where tick is 1+ digits (01, 2, 003, etc.)
      const m = raw.match(/^(.*)\.(\d+)$/);
      if (!m) return { base: raw, tick: 0 };

      const base = (m[1] || '').trim();
      const tick = parseInt(m[2], 10);
      return { base, tick: Number.isFinite(tick) ? tick : 0 };
    }

    function computeMaxTickByYear(visibleTimelines) {
      const ctx = { timelines: state.timelines, cache: new Map(), stack: [] };
      const maxTickByYear = new Map();

      for (const tl of visibleTimelines) {
        const anchorYear = resolveTimelineAnchorYear(tl, ctx);

        // IMPORTANT: only real events, not the generated anchor chip
        const allEvents = tl.events || [];

        for (const ev of allEvents) {
          const { base, tick } = splitBaseAndTick(ev.year);
          if (!base) continue;

          const absYear = parseYearToken(base, anchorYear, ctx).year;
          const prev = maxTickByYear.get(absYear) || 0;
          if (tick > prev) maxTickByYear.set(absYear, tick);
        }
      }

      return maxTickByYear;
    }



    // Add this helper (or replace your existing one if present)
    function formatWithCommas(x) {
      // Inserts commas every 3 digits, e.g. 1234567 -> 1,234,567
      return String(x).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }

    // Replace your current formatYearSigned with this version
    function formatYearSigned(y) {
      const abs = Math.abs(y);
      const numStr = abs >= 10000 ? formatWithCommas(abs) : String(abs);
      return y < 0 ? `${numStr}bc` : numStr;
    }

    // Wrap parenthetical parts of a title in <span>(...)</span> safely.
    function formatTitleWithParens(title) {
      if (!title) return '';
      const safe = escapeHtml(String(title));
      // Turn (...) → <span>(...)</span> (supports multiple sets)
      return safe.replace(/\(([^)]+)\)/g, (_m, inner) => `<span>(${inner})</span>`);
    }

    function getAnchorEvent(tl) {
      if (!tl) return null;

      // We store tl.year as a token string now ("2000" or "5aKANTO")
      // The grid uses resolveTimelineAnchorYear() to place it.
      return {
        year: String(tl.year || '2000'),   // token, not forced numeric
        title: tl.title || '(Untitled)',
        desc: tl.description || '',
        image: tl.image || '',
        __isAnchor: true,
      };
    }


    // Replace your current parseYearToken with this version
    function parseYearToken(str, baseYear = 2000, ctx = null) {
      if (typeof str !== 'string') throw new Error('Year must be a string');
      const s = str.trim();

      const timelines =
        ctx?.timelines ||
        (typeof state !== 'undefined' ? state.timelines : []) ||
        [];

      // 1) Plain numeric / BC / YA: 1999 | 300bc | 20ya
      {
        const m = s.toLowerCase().match(/^(\d+)(bc|ya)?$/);
        if (m) {
          const n = parseInt(m[1], 10);
          if (Number.isNaN(n)) throw new Error('Invalid year number: ' + str);

          const suffix = m[2] || '';

          // baseYear is the timeline's anchor year for events (passed in by the caller)
          const anchor = Number.isFinite(+baseYear) ? +baseYear : 2000;

          let year;
          if (suffix === 'bc') {
            year = -n;
          } else if (suffix === 'ya') {
            // NEW RULE:
            // - If YA < 1000: interpret relative to the event's timeline anchor year (baseYear/anchor)
            // - Otherwise: interpret relative to the fixed year 2000
            const yaBase = n < 1000 ? anchor : 2000;
            year = yaBase - n;
          } else {
            year = n;
          }

          return { year, isBC: year < 0 };
        }
      }

      // 2) "After another anchor": 5aKANTO  (years after timeline "Kanto" anchor year)
      // Allow letters/numbers/spaces/hyphens/underscores in name (everything after the 'a').
      {
        const m = s.match(/^(\d+)\s*a\s*(.+)$/i);
        if (m) {
          const offset = parseInt(m[1], 10);
          const name = m[2].trim();
          if (!name) throw new Error('Invalid anchor reference (missing name): ' + str);

          const ref = getTimelineByName(name, timelines);
          if (!ref) throw new Error(`Unknown anchor timeline "${name}" in token: ${str}`);

          // Resolve referenced timeline anchor year (supports chaining)
          const localCtx = ctx || { timelines, cache: new Map(), stack: [] };
          const refAnchorYear = resolveTimelineAnchorYear(ref, localCtx);

          const year = refAnchorYear + offset;
          return { year, isBC: year < 0 };
        }
      }

      throw new Error('Invalid year token: ' + str);
    }

    const sortEventsByYear = (a, b) => {
      const ay = parseYearToken(a.year).year;
      const by = parseYearToken(b.year).year;
      return ay - by;
    };

    function collectAllYears(timelines) {
      const set = new Set();
      const ctx = { timelines, cache: new Map(), stack: [] };

      for (const tl of timelines) {
        const anchorYear = resolveTimelineAnchorYear(tl, ctx);

        // include anchor year
        set.add(anchorYear);

        // include events (ya is relative to *this* timeline's resolved anchor year)
        for (const ev of tl.events || []) {
          const { base } = splitBaseAndTick(ev.year);
          if (!base) continue;
          set.add(parseYearToken(base, anchorYear, ctx).year);
        }
      }

      return Array.from(set).sort((a, b) => a - b);
    }


    function resolveImageSrc(input) {
      if (!input) return '';
      const s = String(input).trim();
      if (/^https?:\/\//i.test(s)) return s;     // absolute URL
      if (s.startsWith('/')) return s;           // absolute site path
      return `images/${s}`;                      // slug/subpath → images/<path>
    }

    let descTooltipEl = null;

    function ensureDescTooltip() {
      if (descTooltipEl) return descTooltipEl;

      const el = document.createElement('div');
      el.id = 'desc-tooltip';
      el.style.position = 'fixed';
      el.style.zIndex = '9999';
      el.style.pointerEvents = 'none';
      el.style.display = 'none';

      document.body.appendChild(el);
      descTooltipEl = el;

      // Hide tooltip on scroll / click / escape
      window.addEventListener('scroll', hideDescTooltip, true);
      window.addEventListener('pointerdown', hideDescTooltip, true);
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape') hideDescTooltip(); });

      return el;
    }

    function showDescTooltip(html, clientX, clientY) {
      const el = ensureDescTooltip();
      el.innerHTML = html;

      // show first so we can measure
      el.style.display = 'block';

      const pad = 12;
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const rect = el.getBoundingClientRect();

      let x = clientX + pad;
      let y = clientY + pad;

      if (x + rect.width + pad > vw) x = Math.max(pad, vw - rect.width - pad);
      if (y + rect.height + pad > vh) y = Math.max(pad, vh - rect.height - pad);

      el.style.left = `${x}px`;
      el.style.top = `${y}px`;
    }

    function hideDescTooltip() {
      if (!descTooltipEl) return;
      descTooltipEl.style.display = 'none';
    }


    /** Simple, safe-ish markdown → HTML for chips.
 * Supports: links [text](https://...), **bold**, *italic*, `code`, and line breaks.
 * Intentionally conservative to avoid XSS and layout surprises.
 */
    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }
    function markdownToHtml(md) {
      if (!md) return '';
      let s = escapeHtml(String(md).replace(/\r\n/g, '\n'));

      // Inline code first to protect contents
      s = s.replace(/`([^`]+)`/g, (_m, code) => `<code>${code}</code>`);

      // Links: [label](https://example.com) — only allow http/https
      s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g, (_m, label, url) => {
        const safeLabel = escapeHtml(label);
        const safeUrl = escapeHtml(url);
        return `<a href="${safeUrl}" target="_blank" rel="noopener">${safeLabel}</a>`;
      });

      // Bold, then italics (simple, non-greedy)
      s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      s = s.replace(/\*([^*]+)\*/g, '<em>$1</em>');

      // Line breaks
      s = s.replace(/\n/g, '<br>');

      return s;
    }


    /*****************
     * Theme toggle  *
     *****************/
    function applyTheme() {
      document.body.setAttribute('data-theme', state.theme);
    }
    function toggleTheme() {
      state.theme = state.theme === 'light' ? 'dark' : 'light';
      applyTheme();
    }

    /**********************
     * Rendering (Grid)   *
     **********************/

    function makeConfirmable(btn, onConfirm, {
      idleText = btn.textContent || 'Delete',
      confirmText = 'Confirm',
      timeoutMs = 3000
    } = {}) {
      let timer = null;

      const reset = () => {
        btn.textContent = idleText;
        btn.classList.remove('confirm');
        btn.dataset.confirm = '';
        if (timer) { clearTimeout(timer); timer = null; }
      };

      btn.onclick = (e) => {
        if (btn.dataset.confirm === 'true') {
          reset();
          onConfirm(e);
          return;
        }
        btn.dataset.confirm = 'true';
        btn.textContent = confirmText;
        btn.classList.add('confirm');
        timer = setTimeout(reset, timeoutMs);
      };

      // Optional niceties
      btn.addEventListener('mouseleave', reset);
      btn.addEventListener('blur', reset);

      return reset;
    }


    function renderTimelineList() {
      const list = document.getElementById('timeline-list');
      list.innerHTML = '';

      // Track current drag state locally
      let dragId = null;

      const clearDragClasses = () => {
        list.querySelectorAll('.option').forEach(el => {
          el.classList.remove('dragging', 'drag-over');
        });
      };

      const onDropReorder = (dropId) => {
        if (!dragId || dragId === dropId) return;

        const from = indexOfTimelineId(dragId);
        const to = indexOfTimelineId(dropId);
        if (from < 0 || to < 0) return;

        moveTimeline(from, to);

        // Re-render everything that depends on order
        renderTimelineList();
        renderToggleBar();
        renderYearGrid();

        // Keep selection stable
        if (state.selectedTimelineId) {
          const selectedEl = list.querySelector(`.option[data-id="${state.selectedTimelineId}"]`);
          if (selectedEl) selectedEl.setAttribute('aria-selected', 'true');
        }
      };

      // Build options
      for (const tl of state.timelines) {
        const isSelected = (state.selectedEditorKind === 'timeline') && (tl.id === state.selectedTimelineId);

        const opt = document.createElement('div');
        opt.className = 'option';
        opt.setAttribute('role', 'option');
        opt.setAttribute('data-id', tl.id);
        opt.setAttribute('aria-selected', isSelected ? 'true' : 'false');
        opt.setAttribute('tabindex', isSelected ? '0' : '-1');
        opt.setAttribute('data-state', 'default');
        opt.style.setProperty('--tlCol', tl.color || '#8aa');
        opt.textContent = tl.title || '(Untitled)';

        // Click + keyboard behaviour (your existing behaviour)
        opt.addEventListener('click', () => selectTimeline(tl.id));
        opt.addEventListener('keydown', (e) => handleListboxKey(e, opt));

        // --- Drag & Drop reordering ---
        opt.draggable = true;

        opt.addEventListener('dragstart', (e) => {
          dragId = tl.id;
          opt.classList.add('dragging');

          // Some browsers need data set for DnD to work
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', tl.id);
        });

        opt.addEventListener('dragend', () => {
          dragId = null;
          clearDragClasses();
        });

        opt.addEventListener('dragenter', (e) => {
          e.preventDefault();
          if (!dragId || dragId === tl.id) return;
          opt.classList.add('drag-over');
        });

        opt.addEventListener('dragleave', () => {
          opt.classList.remove('drag-over');
        });

        opt.addEventListener('dragover', (e) => {
          // Must prevent default to allow drop
          e.preventDefault();
          if (!dragId || dragId === tl.id) return;
          e.dataTransfer.dropEffect = 'move';
        });

        opt.addEventListener('drop', (e) => {
          e.preventDefault();

          // Prefer the stored dragId, but also read transfer data (safety)
          const droppedOnId = tl.id;
          const fromId = dragId || e.dataTransfer.getData('text/plain');

          dragId = fromId;
          onDropReorder(droppedOnId);
          clearDragClasses();
        });

        list.appendChild(opt);
      }

      // Ensure at least one is tabbable for keyboard users
      const focusable = list.querySelector('[tabindex="0"]') || list.querySelector('.option');
      if (focusable && document.activeElement.closest('#timeline-list')) {
        focusable.focus();
      }
    }


    function selectTimeline(id) {
      state.selectedEditorKind = 'timeline';
      state.selectedEditorKind = 'timeline';
      state.selectedTimelineId = id;
      state.selectedStoryTimelineId = null;
      state.selectedStoryTimelineId = null;
      renderTimelineList();
      renderStoryTimelineList();
      renderTimelineEditor();   // refresh details panel
    }

    function selectStoryTimeline(id) {
      state.selectedEditorKind = 'story';
      state.selectedStoryTimelineId = id;
      state.selectedTimelineId = null;
      renderTimelineList();
      renderStoryTimelineList();
      renderTimelineEditor();   // refresh details panel
    }

    function renderStoryTimelineList() {
      const list = document.getElementById('story-timeline-list');
      if (!list) return;
      list.innerHTML = '';

      for (const st of state.storyTimelines) {
        const isSelected = st.id === state.selectedStoryTimelineId && state.selectedEditorKind === 'story';

        const opt = document.createElement('div');
        opt.className = 'option';
        opt.setAttribute('role', 'option');
        opt.setAttribute('data-id', st.id);
        opt.setAttribute('aria-selected', isSelected ? 'true' : 'false');
        opt.setAttribute('tabindex', isSelected ? '0' : '-1');
        opt.textContent = st.title || '(Story)';

        opt.addEventListener('click', () => selectStoryTimeline(st.id));
        opt.addEventListener('keydown', (e) => handleStoryListboxKey(e, opt));

        list.appendChild(opt);
      }

      const focusable = list.querySelector('[tabindex="0"]') || list.querySelector('.option');
      if (focusable && document.activeElement.closest('#story-timeline-list')) {
        focusable.focus();
      }
    }

    function handleStoryListboxKey(e, currentOpt) {
      const list = document.getElementById('story-timeline-list');
      const opts = Array.from(list.querySelectorAll('.option'));
      const idx = opts.indexOf(currentOpt);

      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        currentOpt.click();
        return;
      }

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        const next = opts[Math.min(idx + 1, opts.length - 1)];
        if (next) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          next.setAttribute('tabindex', '0');
          next.focus();
        }
        return;
      }

      if (e.key === 'ArrowUp') {
        e.preventDefault();
        const prev = opts[Math.max(idx - 1, 0)];
        if (prev) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          prev.setAttribute('tabindex', '0');
          prev.focus();
        }
        return;
      }

      if (e.key === 'Home') {
        e.preventDefault();
        const first = opts[0];
        if (first) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          first.setAttribute('tabindex', '0');
          first.focus();
        }
      }
      if (e.key === 'End') {
        e.preventDefault();
        const last = opts[opts.length - 1];
        if (last) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          last.setAttribute('tabindex', '0');
          last.focus();
        }
      }
    }

    function handleListboxKey(e, currentOpt) {
      const list = document.getElementById('timeline-list');
      const opts = Array.from(list.querySelectorAll('.option'));
      const idx = opts.indexOf(currentOpt);

      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        currentOpt.click();
        return;
      }

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        const next = opts[Math.min(idx + 1, opts.length - 1)];
        if (next) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          next.setAttribute('tabindex', '0');
          next.focus();
        }
        return;
      }

      if (e.key === 'ArrowUp') {
        e.preventDefault();
        const prev = opts[Math.max(idx - 1, 0)];
        if (prev) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          prev.setAttribute('tabindex', '0');
          prev.focus();
        }
        return;
      }

      // Optional: Home/End keys
      if (e.key === 'Home') {
        e.preventDefault();
        const first = opts[0];
        if (first) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          first.setAttribute('tabindex', '0');
          first.focus();
        }
      }
      if (e.key === 'End') {
        e.preventDefault();
        const last = opts[opts.length - 1];
        if (last) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          last.setAttribute('tabindex', '0');
          last.focus();
        }
      }
    }


    function renderToggleBar() {
      // Ensure we have a container just before the grid
      const viewport = document.querySelector('.viewport');
      const gridEl = document.getElementById('grid');

      let container = viewport.querySelector('.toggles-container');
      if (!container) {
        container = document.createElement('div');
        container.className = 'toggles-container';
        viewport.insertBefore(container, gridEl);
      }
      container.innerHTML = '';

      // --- Timeline toggles (existing behaviour) ---
      let tlBar = container.querySelector('.timeline-toggles');
      if (!tlBar) {
        tlBar = document.createElement('div');
        tlBar.className = 'timeline-toggles';
        container.appendChild(tlBar);
      }
      tlBar.innerHTML = '';

      if (!state.timelines.length) {
        tlBar.innerHTML = '<span class="muted small">No timelines yet.</span>';
      } else {
        for (const tl of state.timelines) {
          const id = `tgl_${tl.id}`;
          const wrap = document.createElement('label');
          wrap.className = 'toggle';
          wrap.style.setProperty('--tlCol', tl.color || '#8aa');

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.id = id;
          cb.checked = !state.hiddenTimelineIds.has(tl.id);
          cb.onchange = () => {
            if (cb.checked) state.hiddenTimelineIds.delete(tl.id);
            else state.hiddenTimelineIds.add(tl.id);
            renderYearGrid();
          };

          const txt = document.createElement('span');
          txt.className = 'label';
          txt.textContent = tl.title || '(Untitled)';

          wrap.appendChild(cb);
          wrap.appendChild(txt);
          tlBar.appendChild(wrap);
        }
      }

      // --- Story timeline toggles ---
      let stBar = container.querySelector('.story-toggles');
      if (!stBar) {
        stBar = document.createElement('div');
        stBar.className = 'story-toggles';
        container.appendChild(stBar);
      }
      stBar.innerHTML = '';

      if (!state.storyTimelines.length) {
        stBar.innerHTML = '<span class="muted small">No story timelines yet.</span>';
      } else {
        for (const st of state.storyTimelines) {
          const wrap = document.createElement('label');
          wrap.className = 'toggle';

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.checked = !state.hiddenStoryTimelineIds.has(st.id);
          cb.onchange = () => {
            if (cb.checked) state.hiddenStoryTimelineIds.delete(st.id);
            else state.hiddenStoryTimelineIds.add(st.id);
            renderYearGrid();
          };

          const txt = document.createElement('span');
          txt.className = 'label';
          txt.textContent = st.title || '(Story)';

          wrap.appendChild(cb);
          wrap.appendChild(txt);
          stBar.appendChild(wrap);
        }
      }

      // --- Content toggles (NEW) ---
      let contentBar = container.querySelector('.content-toggles');
      if (!contentBar) {
        contentBar = document.createElement('div');
        contentBar.className = 'content-toggles';
        container.appendChild(contentBar);
      }
      contentBar.innerHTML = '';

      // helper to build a switch
      const mkSwitch = (labelText, checked, onChange) => {
        const lbl = document.createElement('label');
        lbl.className = 'toggle content-toggle';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = checked;
        cb.onchange = () => { onChange(cb.checked); };

        const text = document.createElement('span');
        text.className = 'label';
        text.textContent = labelText;

        lbl.appendChild(cb);
        lbl.appendChild(text);
        return lbl;
      };

      // Descriptions
      contentBar.appendChild(
        mkSwitch('Descriptions', state.showDescriptions, (v) => {
          state.showDescriptions = v;
          renderYearGrid();
        })
      );

      // Images
      contentBar.appendChild(
        mkSwitch('Images', state.showImages, (v) => {
          state.showImages = v;
          renderYearGrid();
        })
      );
    }

    function renderApp() {
      applyTheme();
      renderHeader();
      renderToggleBar();
      renderYearGrid();
      renderEditorUI();
    }

    function renderHeader() {
      document.getElementById('btn-theme').onclick = toggleTheme;
      document.getElementById('btn-edit').onclick = () => enterEditMode();
      // Import/Download now live in the editor header
    }

    function renderStoryTimelineRow(grid, storyTimeline, columns, maxTickByYear) {
      const ctx = { timelines: state.timelines, cache: new Map(), stack: [] };

      // Build pages per year
      const pagesByYear = buildStoryPagesByYear(storyTimeline, maxTickByYear, ctx);

      // Label cell
      const label = document.createElement('div');
      label.className = 'cell label-cell story-label';
      const labelinner = document.createElement('div');
      labelinner.className = 'label-inner';
      labelinner.textContent = storyTimeline.title || '(Story Timeline)';
      label.appendChild(labelinner);
      grid.appendChild(label);

      // Cells
      for (let i = 1; i < columns.length; i++) {
        const col = columns[i];

        if (col.type === 'gap') {
          const cell = document.createElement('div');
          cell.className = 'cell gap-body story-gap';
          const marker = document.createElement('div');
          marker.className = 'event collapse';
          marker.textContent = '~';
          cell.appendChild(marker);
          grid.appendChild(cell);
          continue;
        }

        const y = col.year;
        const cell = document.createElement('div');
        cell.className = 'cell year-body story-year';

        const tickCount = maxTickByYear.get(y) || 0;
        const pages = pagesByYear.get(y) || [];

        if (!pages.length) {
          grid.appendChild(cell);
          continue;
        }

        renderStoryYearCellPages(cell, pages, tickCount);
        grid.appendChild(cell);
      }
    }
    function renderYearGrid() {
      const grid = document.getElementById('grid');
      grid.innerHTML = '';

      // filter visible timelines
      const visibleTimelines = state.timelines.filter(t => !state.hiddenTimelineIds.has(t.id));

      if (!visibleTimelines.length) {
        grid.innerHTML = '<div class="muted">No timelines selected. Toggle one above to show it.</div>';
        return;
      }

      // collect years from VISIBLE ones only
      const years = collectAllYears(visibleTimelines);
      const { columns, colCount } = buildYearColumns(years);

      // NEW: per-year maximum tick count across visible timelines
      const maxTickByYear = computeMaxTickByYear(visibleTimelines);

      grid.style.gridTemplateColumns = `var(--label-col-w) repeat(${colCount - 1}, var(--year-col-w))`;

      // header...
      const labelHeader = document.createElement('div');
      labelHeader.className = 'cell header label-header';
      labelHeader.textContent = '';
      grid.appendChild(labelHeader);

      for (let i = 1; i < columns.length; i++) {
        const col = columns[i];
        const cell = document.createElement('div');
        if (col.type === 'year') {
          cell.className = 'cell header year-header';
          cell.textContent = formatYearSigned(col.year);
        } else {
          cell.className = 'cell header gap-header';
          cell.textContent = '…';
        }
        grid.appendChild(cell);
      }

      // --- Story timelines (render above normal timelines) ---
      const visibleStoryTimelines = state.storyTimelines.filter(st => !state.hiddenStoryTimelineIds.has(st.id));
      for (const st of visibleStoryTimelines) {
        renderStoryTimelineRow(grid, st, columns, maxTickByYear);
      }

      // body rows ONLY for visible timelines
      for (const tl of visibleTimelines) {
        renderTimelineRow(grid, tl, columns, maxTickByYear);
      }
    }


    function buildYearColumns(years) {
      const columns = [{ type: 'label' }];
      if (years.length === 0) return { columns, colCount: 1 };
      for (let i = 0; i < years.length; i++) {
        const y = years[i];
        columns.push({ type: 'year', year: y });
        if (i < years.length - 1) {
          const next = years[i + 1];
          if (next - y > 1) columns.push({ type: 'gap' });
        }
      }
      return { columns, colCount: columns.length };
    }

    function renderTimelineRow(grid, timeline, columns, maxTickByYear) {
      const tlCol = timeline.color || '#8aa';
      const ctx = { timelines: state.timelines, cache: new Map(), stack: [] };
      const anchorYear = resolveTimelineAnchorYear(timeline, ctx);

      // Map: absYear -> { baseEvents:[{ev, base}], ticksByN: Map<int, [{ev, base}]> }
      const byYear = new Map();
      const ensureBucket = (absYear) => {
        if (!byYear.has(absYear)) byYear.set(absYear, { baseEvents: [], ticksByN: new Map() });
        return byYear.get(absYear);
      };

      const pushTick = (bucket, tick, ev, base) => {
        if (!bucket.ticksByN.has(tick)) bucket.ticksByN.set(tick, []);
        bucket.ticksByN.get(tick).push({ ev, base });
      };

      // 2) Normal events (sorted by abs year then tick)
      const sortedEvents = (timeline.events || []).slice().sort((a, b) => {
        const aa = splitBaseAndTick(a.year);
        const bb = splitBaseAndTick(b.year);
        const ay = parseYearToken(aa.base, anchorYear, ctx).year;
        const by = parseYearToken(bb.base, anchorYear, ctx).year;
        if (ay !== by) return ay - by;
        return (aa.tick || 0) - (bb.tick || 0);
      });

      for (const ev of sortedEvents) {
        const { base, tick } = splitBaseAndTick(ev.year);
        if (!base) continue;

        const y = parseYearToken(base, anchorYear, ctx).year;
        const bucket = ensureBucket(y);

        if (tick > 0) pushTick(bucket, tick, ev, base);
        else bucket.baseEvents.push({ ev, base });
      }

      // Label cell
      const label = document.createElement('div');
      label.className = 'cell label-cell';
      const labelinner = document.createElement('div');
      labelinner.className = 'label-inner';
      labelinner.textContent = timeline.title || '(Untitled)';
      label.appendChild(labelinner);
      label.style.setProperty('--tlCol', tlCol);
      grid.appendChild(label);

      // Cells
      for (let i = 1; i < columns.length; i++) {
        const col = columns[i];

        if (col.type === 'gap') {
          const cell = document.createElement('div');
          cell.className = 'cell gap-body';
          cell.style.setProperty('--tlCol', tlCol);
          const marker = document.createElement('div');
          marker.className = 'event collapse';
          marker.textContent = '~';
          cell.appendChild(marker);
          grid.appendChild(cell);
          continue;
        }

        const y = col.year;
        const cell = document.createElement('div');
        cell.className = 'cell year-body';
        cell.style.setProperty('--tlCol', tlCol);

        const bucket = byYear.get(y);
        if (!bucket) {
          grid.appendChild(cell);
          continue;
        }

        const tickCount = maxTickByYear?.get(y) || 0;
        const hasTicks = bucket.ticksByN.size > 0;

        if (!hasTicks) {
          // Normal behaviour: render all base events as chips
          for (const be of bucket.baseEvents) cell.appendChild(renderEventChip(be.ev));
          grid.appendChild(cell);
          continue;
        }

        // --- NEW: choose container base by matching tick base token ---
        // Find the first tick's base token (lowest tick, first entry)
        let preferredBaseToken = null;
        const tickNums = Array.from(bucket.ticksByN.keys()).sort((a, b) => a - b);
        if (tickNums.length) {
          const firstTickList = bucket.ticksByN.get(tickNums[0]) || [];
          preferredBaseToken = firstTickList[0]?.base || null;
        }

        // Prefer a non-anchor base event matching preferredBaseToken (e.g., "0ya")
        let containerBaseEntry =
          (preferredBaseToken
            ? bucket.baseEvents.find(be => be.base === preferredBaseToken)
            : null) || bucket.baseEvents[0] || null;

        const containerChip = renderYearContainerChip({
          baseEvent: containerBaseEntry ? containerBaseEntry.ev : null,
          tickEventsByN: bucket.ticksByN,
          tickCount,
          missing: !containerBaseEntry
        });

        cell.appendChild(containerChip);

        // Render extra base events (excluding the one used as container)
        for (const be of bucket.baseEvents) {
          if (containerBaseEntry && be === containerBaseEntry) continue;
          cell.appendChild(renderEventChip(be.ev));
        }

        grid.appendChild(cell);
      }
    }
    function renderSceneTickEventCard(ev) {
      const card = document.createElement('div');
      card.className = 'scenetick-event';

      const hasImg = !!ev.image && state.showImages;
      const hasDesc = !!(ev.desc && String(ev.desc).trim()) && state.showDescriptions;
      const hasHiddenDesc = !!(ev.desc && String(ev.desc).trim()) && !state.showDescriptions;

      // NEW: add .noimage class when there is no visible image
      if (!hasImg) {
        card.classList.add('noimage');
      }

      if (hasHiddenDesc) {
        card.addEventListener('pointerenter', (e) => {
          showDescTooltip(
            `<div class="chip-desc">${markdownToHtml(ev.desc)}</div>`,
            e.clientX,
            e.clientY
          );
        });
        card.addEventListener('pointermove', (e) => {
          showDescTooltip(
            `<div class="chip-desc">${markdownToHtml(ev.desc)}</div>`,
            e.clientX,
            e.clientY
          );
        });
        card.addEventListener('pointerleave', hideDescTooltip);
      }

      if (hasImg) {
        const img = document.createElement('img');
        img.loading = 'lazy';
        img.decoding = 'async';
        img.alt = ev.title ? String(ev.title) : 'scene tick image';
        img.src = resolveImageSrc(ev.image);
        img.className = 'tick-img';
        card.appendChild(img);
      }

      const body = document.createElement('div');
      body.className = 'tick-body';

      const t = document.createElement('div');
      t.className = 'tick-title';
      t.innerHTML = formatTitleWithParens(ev.title || '');
      body.appendChild(t);

      if (hasDesc) {
        const d = document.createElement('div');
        d.className = 'tick-desc';
        d.innerHTML = markdownToHtml(ev.desc);
        body.appendChild(d);
      }

      card.appendChild(body);
      return card;
    }

    function renderYearContainerChip({ baseEvent, tickEventsByN, tickCount, missing }) {
      const chip = document.createElement('div');
      chip.className = 'event chip year-container';
      if (missing) chip.classList.add('missing');

      // Base event flags (container's own image/desc)
      const hasBase = !!baseEvent;
      const baseHasImg = hasBase && !!baseEvent.image && state.showImages;
      const baseHasDesc = hasBase && !!(baseEvent.desc && String(baseEvent.desc).trim()) && state.showDescriptions;
      const baseHasHiddenDesc = hasBase && !!(baseEvent.desc && String(baseEvent.desc).trim()) && !state.showDescriptions;

      if (baseHasHiddenDesc) {
        chip.addEventListener('pointerenter', (e) => {
          showDescTooltip(`<div class="chip-desc">${markdownToHtml(baseEvent.desc)}</div>`, e.clientX, e.clientY);
        });
        chip.addEventListener('pointermove', (e) => {
          showDescTooltip(`<div class="chip-desc">${markdownToHtml(baseEvent.desc)}</div>`, e.clientX, e.clientY);
        });
        chip.addEventListener('pointerleave', hideDescTooltip);
      }

      chip.classList.toggle('no-img', !baseHasImg);
      chip.classList.toggle('no-desc', !baseHasDesc);

      // Base image
      if (baseHasImg) {
        const img = document.createElement('img');
        img.loading = 'lazy';
        img.decoding = 'async';
        img.alt = baseEvent.title ? String(baseEvent.title) : 'event image';
        img.src = resolveImageSrc(baseEvent.image);
        img.className = 'chip-img';
        chip.appendChild(img);
      }

      const content = document.createElement('div');
      content.className = 'chip-content';

      const title = document.createElement('div');
      title.className = 'chip-title';
      title.innerHTML = hasBase
        ? formatTitleWithParens(baseEvent.title || '')
        : '<span>(Missing year event)</span>';
      content.appendChild(title);

      if (baseHasDesc) {
        const desc = document.createElement('div');
        desc.className = 'chip-desc';
        desc.innerHTML = markdownToHtml(baseEvent.desc);
        content.appendChild(desc);
      }

      // Tick rail
      const rail = document.createElement('div');
      rail.className = 'sceneticks';
      rail.style.setProperty('--tickCount', String(Math.max(0, tickCount | 0)));

      // Always render 1..tickCount slots (empty gaps visible)
      for (let t = 1; t <= (tickCount | 0); t++) {
        const slot = document.createElement('div');
        slot.className = 'scenetick-slot';
        slot.dataset.tick = String(t);

        const evs = tickEventsByN.get(t) || [];
        for (const entry of evs) {
          slot.appendChild(renderSceneTickEventCard(entry.ev));
        }

        rail.appendChild(slot);
      }

      content.appendChild(rail);
      chip.appendChild(content);
      return chip;
    }


    function renderEventChip(ev) {
      const chip = document.createElement('div');
      chip.className = 'event chip';

      // determine visibility flags up front
      const hasImg = !!ev.image && state.showImages;
      const hasDesc = !!(ev.desc && String(ev.desc).trim()) && state.showDescriptions;

      const hasHiddenDesc = !!(ev.desc && String(ev.desc).trim()) && !state.showDescriptions;

      if (hasHiddenDesc) {
        chip.addEventListener('pointerenter', (e) => {
          showDescTooltip(`<div class="chip-desc">${markdownToHtml(ev.desc)}</div>`, e.clientX, e.clientY);
        });
        chip.addEventListener('pointermove', (e) => {
          // keep it tracking the pointer
          showDescTooltip(`<div class="chip-desc">${markdownToHtml(ev.desc)}</div>`, e.clientX, e.clientY);
        });
        chip.addEventListener('pointerleave', hideDescTooltip);
      }


      // set modifier classes for styling
      chip.classList.toggle('no-img', !hasImg);
      chip.classList.toggle('no-desc', !hasDesc);

      // Image
      if (hasImg) {
        const img = document.createElement('img');
        img.loading = 'lazy';
        img.decoding = 'async';
        img.alt = ev.title ? String(ev.title) : 'event image';
        img.src = resolveImageSrc(ev.image);
        img.className = 'chip-img';
        chip.appendChild(img);
      }

      const content = document.createElement('div');
      content.className = 'chip-content';

      const title = document.createElement('div');
      title.className = 'chip-title';
      title.innerHTML = formatTitleWithParens(ev.title || '');
      content.appendChild(title);

      if (hasDesc) {
        const desc = document.createElement('div');
        desc.className = 'chip-desc';
        desc.innerHTML = markdownToHtml(ev.desc);
        content.appendChild(desc);
      }

      chip.appendChild(content);
      return chip;
    }


    /********************
     * Editor / Admin   *
     ********************/
    function enterEditMode() {
      state.editMode = true;
      document.getElementById('editor').classList.remove('hidden');
      document.getElementById('editor').setAttribute('aria-hidden', 'false');
      renderEditorFields();
    }
    function exitEditMode() {
      state.editMode = false;
      document.getElementById('editor').classList.add('hidden');
      document.getElementById('editor').setAttribute('aria-hidden', 'true');
      renderYearGrid();
    }

    function renderEditorUI() {
      // Static handlers within the editor
      document.getElementById('btn-exit-edit').onclick = exitEditMode;
      
document.getElementById('btn-add-timeline').onclick = onAddTimeline;
      document.getElementById('btn-dup-timeline').onclick = onDupTimeline;

      document.getElementById('btn-add-story-timeline').onclick = onAddStoryTimeline;
      document.getElementById('btn-dup-story-timeline').onclick = onDupStoryTimeline;
      makeConfirmable(
        document.getElementById('btn-del-timeline'),
        () => onDelTimeline(),
        { idleText: 'Delete Timeline', confirmText: 'Confirm' }
      );

      
makeConfirmable(
  document.getElementById('btn-del-story-timeline'),
  () => onDelStoryTimeline(),
  { idleText: 'Delete Story Timeline', confirmText: 'Confirm' }
);

document.getElementById('btn-add-sequence').onclick = onAddSequence;

document.getElementById('btn-add-event').onclick = onAddEvent;

      // Import/Download are now here
      const fileImport = document.getElementById('file-import-editor');
      const btnDownload = document.getElementById('btn-download-editor');
      fileImport.onchange = onImportTimelinesJS;
      btnDownload.onclick = downloadTimelinesJS;
    }

    function renderEditorFields() {
      renderTimelineList();
      renderStoryTimelineList();

      // Default selection if none
      const hasTimelineSel = !!state.selectedTimelineId && state.timelines.some(t => t.id === state.selectedTimelineId);
      const hasStorySel = !!state.selectedStoryTimelineId && state.storyTimelines.some(st => st.id === state.selectedStoryTimelineId);

      if (!hasTimelineSel && !hasStorySel) {
        if (state.timelines.length) {
          state.selectedEditorKind = 'timeline';
          state.selectedTimelineId = state.timelines[0].id;
        } else if (state.storyTimelines.length) {
          state.selectedEditorKind = 'story';
          state.selectedStoryTimelineId = state.storyTimelines[0].id;
        } else {
          state.selectedEditorKind = 'timeline';
          state.selectedTimelineId = null;
          state.selectedStoryTimelineId = null;
        }
      } else if (hasTimelineSel && !hasStorySel) {
        state.selectedEditorKind = 'timeline';
      } else if (!hasTimelineSel && hasStorySel) {
        state.selectedEditorKind = 'story';
      }

      renderTimelineList();
      renderStoryTimelineList();

      // Render details for selected
      renderTimelineEditor();
    }


    function getSelectedTimeline() {
      if (state.selectedEditorKind !== 'timeline') return null;
      return state.timelines.find(t => t.id === state.selectedTimelineId) || null;
    }

    function getSelectedStoryTimeline() {
      if (state.selectedEditorKind !== 'story') return null;
      return state.storyTimelines.find(st => st.id === state.selectedStoryTimelineId) || null;
    }


    function sortTimelineEvents(tl) {
      if (!tl || !Array.isArray(tl.events)) return;

      const safeYear = (ev) => {
        try {
          return { ok: true, year: parseYearToken(ev.year).year };
        } catch {
          return { ok: false, year: Number.POSITIVE_INFINITY };
        }
      };

      tl.events = tl.events
        .map((ev, idx) => ({ ev, idx }))
        .sort((A, B) => {
          const ay = safeYear(A.ev);
          const by = safeYear(B.ev);

          // 1) Year (invalid years sort last)
          if (ay.year !== by.year) return ay.year - by.year;

          // 2) Title (case-insensitive, empty titles last-ish)
          const at = String(A.ev.title || '').trim().toLowerCase();
          const bt = String(B.ev.title || '').trim().toLowerCase();

          if (at !== bt) return at.localeCompare(bt);

          // 3) Stable fallback to original order
          return A.idx - B.idx;
        })
        .map(x => x.ev);
    }


    function renderTimelineEditor() {
      // Switch the editor panel based on what is selected (timeline vs story timeline)
      if (state.selectedEditorKind === 'story') {
        renderStoryTimelineEditor();
        return;
      }


      const tl = getSelectedTimeline();

      const normalWrap = document.getElementById('timeline-editor-normal');
      const storyWrap = document.getElementById('timeline-editor-story');
      if (normalWrap) { normalWrap.classList.remove('hidden'); normalWrap.setAttribute('aria-hidden', 'false'); }
      if (storyWrap) { storyWrap.classList.add('hidden'); storyWrap.setAttribute('aria-hidden', 'true'); }


      const titleEl = document.getElementById('tl-title');
      const yearEl = document.getElementById('tl-year');
      const descEl = document.getElementById('tl-desc');
      const imageEl = document.getElementById('tl-image');

      const colorEl = document.getElementById('tl-color');
      const tbody = document.getElementById('events-body');
      const sortBtn = document.getElementById('btn-sort-events');

      if (sortBtn) {
        sortBtn.disabled = !tl;
        sortBtn.onclick = () => {
          if (!tl) return;
          sortTimelineEvents(tl);
          renderTimelineEditor();
          renderYearGrid();
        };
      }

      if (!tl) {
        titleEl.value = '';
        if (yearEl) yearEl.value = '';
        if (descEl) descEl.value = '';
        if (imageEl) imageEl.value = '';
        colorEl.value = '#cccccc';
        tbody.innerHTML = '<tr><td colspan="5" class="muted">No timeline selected</td></tr>';
        return;
      }

      // Ensure fields exist (backwards compatible)
      tl.year = (tl.year === undefined || tl.year === null || String(tl.year).trim() === '')
        ? '2000'
        : String(tl.year).trim();
      tl.description = String(tl.description || '');
      tl.image = String(tl.image || '');

      titleEl.value = tl.title || '';
      if (yearEl) yearEl.value = String(tl.year);
      if (descEl) descEl.value = tl.description;
      if (imageEl) imageEl.value = tl.image;
      colorEl.value = tl.color || '#cccccc';

      titleEl.oninput = debounce(() => {
        tl.title = titleEl.value.trim();
        renderTimelineList();
        renderToggleBar();
        renderYearGrid();
      }, 150);

      if (yearEl) {
        yearEl.oninput = debounce(() => {
          tl.year = yearEl.value.trim();
          renderYearGrid();
        }, 150);
      }

      if (descEl) {
        descEl.oninput = debounce(() => {
          tl.description = descEl.value;
          renderYearGrid();
        }, 150);
      }

      if (imageEl) {
        imageEl.oninput = debounce(() => {
          tl.image = imageEl.value.trim();
          renderYearGrid();
        }, 150);
      }

      colorEl.oninput = debounce(() => {
        tl.color = colorEl.value;
        renderTimelineList();
        renderToggleBar();
        renderYearGrid();
      }, 150);

      // --- Events table (unchanged from your current code) ---
      tbody.innerHTML = '';
      for (let i = 0; i < tl.events.length; i++) {
        const ev = tl.events[i];

        const tr = document.createElement('tr');

        // Year
        const tdYear = document.createElement('td');
        const inYear = document.createElement('input');
        inYear.type = 'text';
        inYear.placeholder = '1994 | 3000000bc | 20ya';
        inYear.value = ev.year || '';
        inYear.oninput = debounce(() => {
          ev.year = inYear.value.trim();
          try {
            // IMPORTANT: validate against this timeline's anchor year
            const ctx = { timelines: state.timelines, cache: new Map(), stack: [] };
            const anchorYear = resolveTimelineAnchorYear(tl, ctx);

            const { base } = splitBaseAndTick(ev.year);
            parseYearToken(base, anchorYear, ctx);
            inYear.classList.remove('invalid');
            renderYearGrid();
          } catch {
            inYear.classList.add('invalid');
          }
        }, 150);
        tdYear.appendChild(inYear);

        // Title
        const tdTitle = document.createElement('td');
        const inTitle = document.createElement('input');
        inTitle.type = 'text';
        inTitle.placeholder = 'Event title (optional)';
        inTitle.value = ev.title || '';
        inTitle.oninput = debounce(() => {
          ev.title = inTitle.value.trim();
          renderYearGrid();
        }, 150);
        tdTitle.appendChild(inTitle);

        // Desc
        const tdDesc = document.createElement('td');
        const inDesc = document.createElement('textarea');
        inDesc.placeholder = 'Description (Markdown supported)';
        inDesc.value = ev.desc || '';
        inDesc.rows = Math.max(3, Math.min(10, (inDesc.value.split('\n').length || 1)));
        inDesc.style.width = '300px';
        inDesc.addEventListener('input', () => {
          inDesc.style.height = 'auto';
          inDesc.style.height = (inDesc.scrollHeight) + 'px';
        });
        inDesc.oninput = debounce(() => {
          ev.desc = inDesc.value;
          renderYearGrid();
        }, 150);
        requestAnimationFrame(() => {
          inDesc.style.height = 'auto';
          inDesc.style.height = (inDesc.scrollHeight) + 'px';
        });
        tdDesc.appendChild(inDesc);

        // Image
        const tdImg = document.createElement('td');
        const wrap = document.createElement('div');
        wrap.className = 'img-cell';

        const inImg = document.createElement('input');
        inImg.type = 'text';
        inImg.placeholder = 'slug.webp | book/slug.webp | https://…';
        inImg.value = ev.image || '';
        inImg.oninput = debounce(() => {
          ev.image = inImg.value.trim();
          imgPreview.src = resolveImageSrc(ev.image);
          renderYearGrid();
        }, 150);

        const imgPreview = document.createElement('img');
        imgPreview.className = 'img-preview';
        imgPreview.loading = 'lazy';
        imgPreview.alt = 'preview';
        imgPreview.src = resolveImageSrc(ev.image);

        wrap.appendChild(inImg);
        wrap.appendChild(imgPreview);
        tdImg.appendChild(wrap);

        // Delete
        const tdDel = document.createElement('td');
        const btnDel = document.createElement('button');
        btnDel.className = 'btn danger';
        btnDel.textContent = 'Delete';
        makeConfirmable(btnDel, () => {
          tl.events.splice(i, 1);
          renderTimelineEditor();
          renderYearGrid();
        }, { idleText: 'Delete', confirmText: 'Confirm' });
        tdDel.appendChild(btnDel);

        tr.appendChild(tdYear);
        tr.appendChild(tdTitle);
        tr.appendChild(tdDesc);
        tr.appendChild(tdImg);
        tr.appendChild(tdDel);
        tbody.appendChild(tr);
      }

      if (!tl.events.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 5;
        td.className = 'muted';
        td.textContent = 'No events yet.';
        tr.appendChild(td);
        tbody.appendChild(tr);
      }
    }

    
function renderStoryTimelineEditor() {
  const normalWrap = document.getElementById('timeline-editor-normal');
  const storyWrap = document.getElementById('timeline-editor-story');

  if (normalWrap) { normalWrap.classList.add('hidden'); normalWrap.setAttribute('aria-hidden', 'true'); }
  if (storyWrap) { storyWrap.classList.remove('hidden'); storyWrap.setAttribute('aria-hidden', 'false'); }

  const st = getSelectedStoryTimeline();

  const titleEl = document.getElementById('st-title');
  const tbody = document.getElementById('sequences-body');
  const addBtn = document.getElementById('btn-add-sequence');
  const delBtn = document.getElementById('btn-del-story-timeline');

  if (addBtn) addBtn.disabled = !st;
  if (delBtn) delBtn.disabled = !st;

  if (!st) {
    if (titleEl) titleEl.value = '';
    if (tbody) tbody.innerHTML = '<tr><td colspan="5" class="muted">No story timeline selected</td></tr>';
    return;
  }

  st.title = String(st.title || '(Story)');
  st.sequences = Array.isArray(st.sequences) ? st.sequences : [];

  if (titleEl) {
    titleEl.value = st.title || '';
    titleEl.oninput = debounce(() => {
      st.title = titleEl.value.trim() || '(Story)';
      renderStoryTimelineList();
      renderToggleBar();
      renderYearGrid();
    }, 150);
  }

  // keep sequences sorted by seq
  st.sequences.sort((a, b) => (a.seq || 0) - (b.seq || 0));

  if (!tbody) return;
  tbody.innerHTML = '';

  for (let i = 0; i < st.sequences.length; i++) {
    const seq = st.sequences[i];
    seq.seq = Number.isFinite(+seq.seq) ? +seq.seq : 0;
    seq.title = String(seq.title || '');
    seq.desc = String(seq.desc || '');
    seq.map = String(seq.map || '');

    const tr = document.createElement('tr');

    // Seq
    const tdSeq = document.createElement('td');
    const inSeq = document.createElement('input');
    inSeq.type = 'number';
    inSeq.step = '1';
    inSeq.value = String(seq.seq || 0);
    inSeq.oninput = debounce(() => {
      seq.seq = parseInt(inSeq.value || '0', 10) || 0;
      renderStoryTimelineEditor();
      renderYearGrid();
    }, 150);
    tdSeq.appendChild(inSeq);

    // Title
    const tdTitle = document.createElement('td');
    const inTitle = document.createElement('input');
    inTitle.type = 'text';
    inTitle.placeholder = 'Sequence title';
    inTitle.value = seq.title || '';
    inTitle.oninput = debounce(() => {
      seq.title = inTitle.value;
      renderYearGrid();
    }, 150);
    tdTitle.appendChild(inTitle);

    // Desc
    const tdDesc = document.createElement('td');
    const inDesc = document.createElement('textarea');
    inDesc.placeholder = 'Description (Markdown supported)';
    inDesc.value = seq.desc || '';
    inDesc.rows = Math.max(3, Math.min(10, (inDesc.value.split('\n').length || 1)));
    inDesc.style.width = '300px';
    inDesc.addEventListener('input', () => {
      inDesc.style.height = 'auto';
      inDesc.style.height = (inDesc.scrollHeight) + 'px';
    });
    inDesc.oninput = debounce(() => {
      seq.desc = inDesc.value;
      renderYearGrid();
    }, 150);
    requestAnimationFrame(() => {
      inDesc.style.height = 'auto';
      inDesc.style.height = (inDesc.scrollHeight) + 'px';
    });
    tdDesc.appendChild(inDesc);

    // Map
    const tdMap = document.createElement('td');
    const inMap = document.createElement('textarea');
    inMap.placeholder = '01\n- Kalos 0ya.01\n- Kalos 0ya.02';
    inMap.value = seq.map || '';
    inMap.rows = Math.max(6, Math.min(20, (inMap.value.split('\n').length || 1)));
    inMap.style.width = '340px';
    inMap.addEventListener('input', () => {
      inMap.style.height = 'auto';
      inMap.style.height = (inMap.scrollHeight) + 'px';
    });
    inMap.oninput = debounce(() => {
      seq.map = inMap.value;
      renderYearGrid();
    }, 150);
    requestAnimationFrame(() => {
      inMap.style.height = 'auto';
      inMap.style.height = (inMap.scrollHeight) + 'px';
    });
    tdMap.appendChild(inMap);

    // Delete
    const tdDel = document.createElement('td');
    const btnDel = document.createElement('button');
    btnDel.className = 'btn danger';
    btnDel.textContent = 'Delete';
    makeConfirmable(btnDel, () => {
      st.sequences.splice(i, 1);
      renderStoryTimelineEditor();
      renderYearGrid();
    }, { idleText: 'Delete', confirmText: 'Confirm' });
    tdDel.appendChild(btnDel);

    tr.appendChild(tdSeq);
    tr.appendChild(tdTitle);
    tr.appendChild(tdDesc);
    tr.appendChild(tdMap);
    tr.appendChild(tdDel);
    tbody.appendChild(tr);
  }

  if (!st.sequences.length) {
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = 5;
    td.className = 'muted';
    td.textContent = 'No sequences yet.';
    tr.appendChild(td);
    tbody.appendChild(tr);
  }
}


function onAddStoryTimeline() {
  const id = 'st_' + Math.random().toString(36).slice(2, 8);
  const st = { id, title: 'New Story Timeline', sequences: [] };
  state.storyTimelines.push(st);
  state.selectedEditorKind = 'story';
  state.selectedStoryTimelineId = id;
  state.selectedTimelineId = null;

  renderStoryTimelineList();
  renderToggleBar();
  renderYearGrid();
  renderTimelineEditor();
}

function onDupStoryTimeline() {
  const st = getSelectedStoryTimeline();
  if (!st) return;
  const copy = JSON.parse(JSON.stringify(st));
  copy.id = 'st_' + Math.random().toString(36).slice(2, 8);
  copy.title = (st.title || '(Story)') + ' (copy)';
  copy.sequences = Array.isArray(copy.sequences) ? copy.sequences : [];

  state.storyTimelines.push(copy);
  state.selectedEditorKind = 'story';
  state.selectedStoryTimelineId = copy.id;
  state.selectedTimelineId = null;

  renderStoryTimelineList();
  renderToggleBar();
  renderYearGrid();
  renderTimelineEditor();
}

function onDelStoryTimeline() {
  const st = getSelectedStoryTimeline();
  if (!st) return;

  const idx = state.storyTimelines.findIndex(x => x.id === st.id);
  if (idx >= 0) state.storyTimelines.splice(idx, 1);

  if (state.storyTimelines.length) {
    state.selectedEditorKind = 'story';
    state.selectedStoryTimelineId = state.storyTimelines[0].id;
    state.selectedTimelineId = null;
  } else if (state.timelines.length) {
    state.selectedEditorKind = 'timeline';
    state.selectedTimelineId = state.timelines[0].id;
    state.selectedStoryTimelineId = null;
  } else {
    state.selectedEditorKind = 'timeline';
    state.selectedTimelineId = null;
    state.selectedStoryTimelineId = null;
  }

  renderStoryTimelineList();
  renderToggleBar();
  renderYearGrid();
  renderTimelineEditor();
}

function onAddSequence() {
  const st = getSelectedStoryTimeline();
  if (!st) return;
  st.sequences = Array.isArray(st.sequences) ? st.sequences : [];
  st.sequences.push({ seq: (st.sequences.length ? Math.max(...st.sequences.map(s => +s.seq || 0)) + 1 : 1), title: '', desc: '', map: '' });
  renderStoryTimelineEditor();
  renderYearGrid();
}

function onAddTimeline() {
      const id = 'tl_' + Math.random().toString(36).slice(2, 8);
      const tl = { id, title: 'New Timeline', color: '#8aa', year: 2000, description: '', image: '', events: [] };
      state.timelines.push(tl);
      state.selectedEditorKind = 'timeline';
      state.selectedTimelineId = id;
      state.selectedStoryTimelineId = null;
      renderTimelineList();     // NEW
      renderToggleBar();
      renderYearGrid();
      renderTimelineEditor();
    }
    function onDupTimeline() {
      const tl = getSelectedTimeline();
      if (!tl) return;
      const copy = JSON.parse(JSON.stringify(tl));
      copy.id = 'tl_' + Math.random().toString(36).slice(2, 8);
      copy.title = (tl.title || '(Untitled)') + ' (copy)';
      state.timelines.push(copy);
      state.selectedEditorKind = 'timeline';
      state.selectedTimelineId = copy.id;
      state.selectedStoryTimelineId = null;
      renderTimelineList();     // NEW
      renderToggleBar();
      renderYearGrid();
      renderTimelineEditor();
    }
    function onDelTimeline() {
      const tl = getSelectedTimeline();
      if (!tl) return;

      const idx = state.timelines.findIndex(t => t.id === tl.id);
      if (idx >= 0) state.timelines.splice(idx, 1);

      if (state.timelines.length) {
        state.selectedEditorKind = 'timeline';
        state.selectedTimelineId = state.timelines[0].id;
        state.selectedStoryTimelineId = null;
      } else if (state.storyTimelines.length) {
        state.selectedEditorKind = 'story';
        state.selectedStoryTimelineId = state.storyTimelines[0].id;
        state.selectedTimelineId = null;
      } else {
        state.selectedEditorKind = 'timeline';
        state.selectedTimelineId = null;
        state.selectedStoryTimelineId = null;
      }

      renderTimelineList();
      renderStoryTimelineList();
      renderToggleBar();
      renderYearGrid();
      renderTimelineEditor();
    }
    function onAddEvent() {
      const tl = getSelectedTimeline();
      if (!tl) return;
      tl.events.push({ year: '1994', title: '', desc: '', image: '' });
      renderTimelineEditor();
      renderYearGrid();
    }

    const debounce = (fn, ms = 200) => {
      let t = null;
      return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
    };

    /**********************
     * Import / Download  *
     **********************/
    async function onImportTimelinesJS(evt) {
      const file = evt.target.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        // For local file use, we just eval into window.TIMELINES_DEFAULT safely via a Blob
        const blobUrl = URL.createObjectURL(new Blob([text], { type: 'text/javascript' }));
        const el = document.createElement('script');
        el.src = blobUrl;
        el.onload = () => {
          URL.revokeObjectURL(blobUrl);
          state.timelines = normalizeTimelines(window.TIMELINES_DEFAULT?.timelines);
          state.storyTimelines = normalizeStoryTimelines(window.TIMELINES_DEFAULT?.storyTimelines);
          state.selectedTimelineId = state.timelines[0]?.id || null;
          state.selectedStoryTimelineId = null;
          state.selectedEditorKind = state.selectedTimelineId ? 'timeline' : (state.storyTimelines[0]?.id ? 'story' : 'timeline');
          renderEditorFields();
          renderToggleBar();
          renderYearGrid();
        };
        el.onerror = (e) => {
          URL.revokeObjectURL(blobUrl);
          alert('Import failed.');
          console.error(e);
        };
        document.head.appendChild(el);
      } catch (err) {
        alert('Import failed: ' + err.message);
        console.error(err);
      } finally {
        evt.target.value = '';
      }
    }

    function downloadTimelinesJS() {
      const code = generateTimelinesModule(state.timelines);
      const blob = new Blob([code], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'story-timelines.js';
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(url);
      a.remove();
    }

    function generateTimelinesModule(timelines) {
      const safeTimelines = JSON.stringify(timelines, null, 2);
      const safeStory = JSON.stringify(state.storyTimelines || [], null, 2);

      return `// Generated by Year Timelines
      window.TIMELINES_DEFAULT = {
        timelines: ${safeTimelines},
        storyTimelines: ${safeStory}
      };
      `;
    }

    function normalizeTimelines(arr) {
      const timelines = Array.isArray(arr) ? arr : [];

      for (const tl of timelines) {
        tl.id ||= 'tl_' + Math.random().toString(36).slice(2, 8);
        tl.title ||= '(Untitled)';
        tl.color ||= '#8aa';

        tl.description = String(tl.description || '');
        tl.image = String(tl.image || '');

        // IMPORTANT: keep year as a token string
        // Accept numbers by converting to string, but don't coerce expressions to 2000.
        if (tl.year === undefined || tl.year === null || String(tl.year).trim() === '') {
          tl.year = '2000';
        } else {
          tl.year = String(tl.year).trim();
        }

        tl.events = Array.isArray(tl.events) ? tl.events : [];
        for (const ev of tl.events) {
          ev.year = String(ev.year || '').trim();
          ev.title = String(ev.title || '');
          ev.desc = String(ev.desc || '');
          ev.image = String(ev.image || '');
        }
      }

      return timelines;
    }



    /************
     * Boot     *
     ************/
    function initState(initialModule) {
      state.timelines = normalizeTimelines(initialModule?.timelines);
      state.storyTimelines = normalizeStoryTimelines(initialModule?.storyTimelines);

      if (state.timelines.length) {
        state.selectedEditorKind = 'timeline';
        state.selectedTimelineId = state.timelines[0].id;
        state.selectedStoryTimelineId = null;
      } else if (state.storyTimelines.length) {
        state.selectedEditorKind = 'story';
        state.selectedStoryTimelineId = state.storyTimelines[0].id;
        state.selectedTimelineId = null;
      } else {
        state.selectedEditorKind = 'timeline';
        state.selectedTimelineId = null;
        state.selectedStoryTimelineId = null;
      }

      state.theme = 'light';
    }
    initState(DATA_DEFAULT);
    renderApp();
  </script>
</body>

</html>