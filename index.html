<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Timelines</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles/timelines.css">
</head>
<body>
  <header>
    <h1>Timelines</h1>
    <div class="meta" id="meta">Loading…</div>
    <div class="err" id="err"></div>
    <div class="actions">
      <button id="btn-theme" type="button">Light</button>
      <button id="btn-collapse" type="button">All Days</button>
      <button id="toggle-editor" type="button">Edit</button>
      <button id="btn-import" class="ghost" type="button">Import</button>
      <button id="btn-download" type="button">Download</button>
    </div>
  </header>
  
  

  <div id="viewport" class="viewport">
    <div id="grid" class="grid" role="table" aria-label="Timelines grid"></div>
  </div>

  <script>
    /** ===================== CONFIG ===================== **/
    const JSON_PATH = 'timelines.json';

    const visualDebug = false;

    const IMAGES_DIR = 'images/';

    // ===== SIZING (edit these) =====
    const GRID_SIZING = {
      horizontal: {
        namesColWidth:  '80px',
        weekColWidth:   'auto',
        timelineRowMin: '50px',
        weekHeaderRow:  'auto',
      }
    };

    const LEGACY_PRESET_CATEGORIES = [
      '', 'OrdinaryWorld','CallToAdventure','RefusalOfTheCall','MeetingTheMentor','CrossingTheThreshold',
      'TestsAlliesEnemies','ApproachToTheInmostCave','TheOrdeal','Reward','TheRoadBack','Resurrection','TheReturn'
    ];

    const IMAGE_EXTS = ['png', 'jpg', 'jpeg', 'webp', 'gif', 'svg', 'avif'];

    /** ===================== SETTINGS (CATEGORIES) ===================== **/
    let settingsState = null;

    const DEFAULT_UI = {
      title: 'Timelines',
      theme: 'light',
      collapseEmptyDays: false,
    };

    const DEFAULT_SETTINGS = {
      ui: { ...DEFAULT_UI },
      categories: Array.from({ length: 12 }, (_, i) => ({
        id: i + 1,
        name: LEGACY_PRESET_CATEGORIES[i + 1] || `Category ${i + 1}`,
        color: '',
        text: 'black'
      }))
    };

    function applyUIFromSettings() {
      const ui = (settingsState?.ui) || DEFAULT_UI;

      const h1 = document.querySelector('header h1');
      if (h1) h1.textContent = ui.title || DEFAULT_UI.title;

      document.body.classList.toggle('theme-dark', ui.theme === 'dark');
      document.body.classList.toggle('theme-light', ui.theme !== 'dark');

      applyGridSizing();  
      syncHeaderControlsFromSettings();
    }


    function getCatById(id) {
      return (settingsState?.categories || []).find(c => c.id === id) || null;
    }
    function getCatIdByName(name) {
      if (!name) return 0;
      const n = name.toLowerCase();
      const found = (settingsState?.categories || []).find(c => c.name.toLowerCase() === n);
      return found ? found.id : 0;
    }
    function getCatName(id) { return getCatById(id)?.name || ''; }

    function toCatId(val) {
      if (val == null) return 0;
      if (typeof val === 'number' && Number.isInteger(val)) return val;
      const s = String(val).trim();
      if (!s) return 0;
      const asNum = Number(s);
      if (Number.isInteger(asNum)) return asNum;
      return getCatIdByName(s);
    }

    /** ===================== SMALL HELPERS ===================== **/
    const $ = (id) => document.getElementById(id);
    const setText = (id, txt) => { const el = $(id); if (el) el.textContent = txt; };

    // Specifics
    function isSpecificWeek(s) { return /^\d{4}-\d{2}$/.test(s || ''); }           // YYYY-WW
    function isSpecificWeekDay(s) { return /^\d{4}-\d{2}-[1-7]$/.test(s || ''); } // YYYY-WW-D

    // Relative dates
    function parseRelDays(s) {                  // "#", "#d", "##D"
      const m = /^(\d+)\s*[dD]?$/.exec(s || '');
      return m ? parseInt(m[1], 10) : null;
    }
    function parseRelWeeks(s) {                  // "#w"
      const m = /^(\d+)\s*[wW]$/.exec(s || '');
      return m ? parseInt(m[1], 10) : null;
    }

    // Duration → days: accepts "#w", "#", or "#d"
    function parseDuration(s) {
      if (isPartDayDur(s)) return { days: 1, isSlice: true }; // bundle chip; never spills
      if (!s) return { days: 0, isSlice: false };
      const w = parseRelWeeks(s);
      if (w != null) return { days: w * 7, isSlice: false };
      const d = parseRelDays(s);
      if (d != null) return { days: d, isSlice: false };
      return { days: 0, isSlice: false };
    }

    // --- New helpers for Start | Duration tokens ---
    function isZeroStart(s){ return String(s||'').trim()==='0'; }      // start next day after previous END
    function isSameDayStart(s){ return String(s||'').trim()==='.'; }   // same day as current bundle
    function isPartDayDur(s){ return String(s||'').trim()==='.'; }     // a slice; always clamps to 1 day


    function syncHeaderControlsFromSettings() {
      const themeBtn = document.getElementById('btn-theme');
      const collapseBtn = document.getElementById('btn-collapse');

      // Theme
      const theme = settingsState?.ui?.theme === 'dark' ? 'dark' : 'light';
      if (themeBtn) {
        themeBtn.textContent = theme === 'dark' ? 'Dark' : 'Light';
        themeBtn.setAttribute('aria-pressed', theme === 'dark' ? 'true' : 'false');
      }

      // Collapse days
      const collapsed = !!settingsState?.ui?.collapseEmptyDays;
      if (collapseBtn) {
        collapseBtn.textContent = collapsed ? 'Collapsed' : 'All Days';
        collapseBtn.setAttribute('aria-pressed', collapsed ? 'true' : 'false');
      }
    }

    function toggleTheme() {
      if (!settingsState.ui) settingsState.ui = { ...DEFAULT_UI };
      settingsState.ui.theme = (settingsState.ui.theme === 'dark') ? 'light' : 'dark';
      applyAllFromSettings();            // applies classes + re-render
      syncHeaderControlsFromSettings();  // refresh button labels
    }

    function isOutsideBuffered(range, dayIdx, pad = 1) {
      if (!range) return true;
      const left  = range.start + pad;  // first inside day
      const right = range.end   - pad;  // exclusive upper bound
      return dayIdx < left || dayIdx >= right;
    }

    
    function stripExt(name) { return name.replace(/\.[^.]+$/, ''); }
    function encSeg(s) { return encodeURIComponent(s).replace(/%2F/g, '/'); }

    function applyGridSizing() {
      const g = document.getElementById('grid');
      if (!g) return;
      const sz = GRID_SIZING.horizontal;

      g.style.setProperty('--names-col-width', sz.namesColWidth);
      g.style.setProperty('--week-header-row', sz.weekHeaderRow);
      g.style.setProperty('--week-col-width', sz.weekColWidth);
      g.style.setProperty('--timeline-row-min', sz.timelineRowMin);
    }

    // Convert any hex (3/4/6/8) to a valid <input type="color"> value (#RRGGBB)
    function toColorInputValue(hex) {
      const norm = normalizeHexColor(hex || '');
      if (!norm) return '#000000';
      let s = norm.replace(/^#/, '');
      // strip alpha if 8 digits
      if (s.length === 8) s = s.slice(0, 6);
      // expand #RGB / #RGBA -> #RRGGBB
      if (s.length === 3) s = s.split('').map(ch => ch + ch).join('');
      if (s.length === 4) s = s.slice(0, 3).split('').map(ch => ch + ch).join('');
      // pad defensively
      if (s.length !== 6) return '#000000';
      return '#' + s.toUpperCase();
    }

    function buildTimelineHeaderEl(tl) {
      const th = document.createElement('div');
      th.className = 'thead';

      // image (fallback to a grey square if missing/not found)
      const insertPh = () => {
        const ph = document.createElement('div');
        ph.className = 'thead-thumb thead-thumb--ph';
        th.appendChild(ph);
      };

      const thumb = makeSmartImgFallback(
        IMAGES_DIR,
        tl.imageName || '',
        'thead-thumb',
        tl.title || ''
      , insertPh);

      if (thumb) th.appendChild(thumb);

      // title span
      const title = document.createElement('span');
      title.className = 'thead-title';
      title.textContent = tl.title || '';
      th.appendChild(title);

      return th;
    }

    function toggleCollapseEmptyDays() {
      if (!settingsState.ui) settingsState.ui = { ...DEFAULT_UI };
      settingsState.ui.collapseEmptyDays = !settingsState.ui.collapseEmptyDays;
      applyAllFromSettings();     // re-renders with new filter
      syncHeaderControlsFromSettings();
    }


    function normalizeEditorState(es) {
      if (!es || !Array.isArray(es.timelines)) return es;

      es.timelines.forEach(tl => {
        if (typeof tl.image !== 'string') tl.image = '';
        if (!Array.isArray(tl.events)) tl.events = [];

        tl.events.forEach(ev => {
          if (typeof ev.location !== 'string') ev.location = '';  // single string
          if (!Array.isArray(ev.characters)) ev.characters = [];  // array
          if (typeof ev.image !== 'string') ev.image = '';
          // (No legacy ev.locations handling anymore)
        });
      });

      if (!Array.isArray(es.seasonal)) es.seasonal = [];
      return es;
    }


    function getCatText(id) { return getCatById(id)?.text || 'black'; }

    function normalizeHexColor(v) {
      const s = String(v || '').trim().replace(/^#/, '');
      if (/^[0-9a-f]{3}$/i.test(s)) return '#' + s;
      if (/^[0-9a-f]{4}$/i.test(s)) return '#' + s;
      if (/^[0-9a-f]{6}$/i.test(s)) return '#' + s;
      if (/^[0-9a-f]{8}$/i.test(s)) return '#' + s;
      return '';
    }

    function applyAllFromSettings() {
      applyUIFromSettings();
      applyStateToRenderer();
    }

    async function tryLoadJSON() {
      try {
        const r = await fetch(`${JSON_PATH}?v=${Date.now()}`, { cache: 'no-store' });
        if (!r.ok) return null;
        const raw = await r.json();
        const combined = coerceCombinedJson(raw);
        if (!Array.isArray(combined.timelines)) return null;
        return combined; // { settings, timelines, seasonal }
      } catch { return null; }
    }


    async function bootstrapState() {
      const disk = await tryLoadJSON();      // single source of truth
      if (disk) {
        settingsState = disk.settings || DEFAULT_SETTINGS;
        editorState   = normalizeEditorState({
          timelines: disk.timelines || [],
          seasonal:  disk.seasonal  || []
        });
        applyUIFromSettings();
        return;
      }

      // If file missing or invalid, start clean (still no localStorage)
      settingsState = DEFAULT_SETTINGS;
      editorState   = normalizeEditorState({ timelines: [], seasonal: [] });
      applyUIFromSettings();
    }

    function toStartDayIdx(rawDate, prevEndDayIdx) {
      if (isSpecificWeekDay(rawDate)) {
        const [Y, W, D] = rawDate.split('-').map(Number);
        const base = isoWeekToDayIdx(`${Y}-${String(W).padStart(2, '0')}`);
        return base + (D - 1); // D:1..7 (Mon..Sun)
      }
      if (isSpecificWeek(rawDate)) {
        return isoWeekToDayIdx(rawDate); // Monday of that week
      }
      // Relative: "#w" OR "#" | "#d"
      const relW = parseRelWeeks(rawDate);
      if (relW != null) {
        const relDays = relW * 7;
        return (prevEndDayIdx == null) ? relDays : (prevEndDayIdx + relDays);
      }
      const relD = parseRelDays(rawDate);
      if (relD != null) {
        return (prevEndDayIdx == null) ? relD : (prevEndDayIdx + relD);
      }
      return null; // invalid
    }



    /** CSV parse */
    function parseCSV(text) {
      const rows = []; let row = [], cur = '', inQ = false;
      for (let i = 0; i < text.length; i++) {
        const ch = text[i], nx = text[i + 1];
        if (ch === '"') { if (inQ && nx === '"') { cur += '"'; i++; } else inQ = !inQ; }
        else if (ch === ',' && !inQ) { row.push(cur); cur = ''; }
        else if ((ch === '\n' || ch === '\r') && !inQ) { if (ch === '\r' && nx === '\n') i++; row.push(cur); cur=''; rows.push(row); row = []; }
        else cur += ch;
      }
      row.push(cur); rows.push(row);
      const maxLen = Math.max(...rows.map(r => r.length));
      return rows.map(r => r.concat(Array(Math.max(0, maxLen - r.length)).fill('')));
    }

    /** Smart image helpers */
    function makeSmartImg(dir, name, className, alt) {
      if (!name) return null;
      const img = document.createElement('img');
      img.className = className || '';
      img.alt = alt || name;
      img.loading = 'lazy';
      const exts = IMAGE_EXTS.slice();
      let i = 0;
      const tryNext = () => { if (i >= exts.length) { img.remove(); return; } img.src = `${dir}${encSeg(name)}.${exts[i++]}`; };
      img.onerror = tryNext; tryNext(); return img;
    }
    function makeSmartImgFallback(dir, name, className, alt, onAllFail) {
      if (!name) { if (typeof onAllFail === 'function') onAllFail(); return null; }
      const img = document.createElement('img');
      img.className = className || ''; img.alt = alt || name; img.loading = 'lazy';
      const exts = IMAGE_EXTS.slice(); let i = 0;
      const tryNext = () => {
        if (i >= exts.length) { img.remove(); if (typeof onAllFail === 'function') onAllFail(); return; }
        img.src = `${dir}${encSeg(name)}.${exts[i++]}`;
      };
      img.onerror = tryNext; tryNext(); return img;
    }

    function prependEventMedia(el, ev, setHasImage) {
      const setFlag = (v) => { if (typeof setHasImage === 'function') setHasImage(!!v); };
      const insertPlaceholder = () => {
        const ph = document.createElement('div');
        ph.className = 'thumb';
        el.prepend(ph);
        setFlag(false);
      };

      if (ev.imageName) {
        const img = makeSmartImgFallback(IMAGES_DIR, ev.imageName, 'thumb', ev.imageName, insertPlaceholder);
        if (img) {
          img.addEventListener('load', () => setFlag(true), { once: true });
          el.prepend(img);
        }
      } else {
        insertPlaceholder();
      }
    }


    function computeTimelineRanges(timelines) {
      return timelines.map(tl => {
        if (!tl.events || tl.events.length === 0) return null;
        let start = Infinity, end = -Infinity;
        for (const ev of tl.events) {
          start = Math.min(start, ev.startIdx);
          end   = Math.max(end, ev.startIdx + ev.durationDays); // end is exclusive
        }
        if (!Number.isFinite(start) || !Number.isFinite(end)) return null;
        return { start, end }; // [start, end)
      });
    }

    /** CSV -> timeline */
    function csvToTimeline(filename, csvText) {
      const rowsRaw = parseCSV(csvText).filter(r => r.some(c => (c || '').trim() !== ''));
      if (!rowsRaw.length) throw new Error('CSV is empty');
      const titleRow = rowsRaw[0];
      const title = (titleRow.find(c => (c || '').trim() !== '') || '').trim() || stripExt(filename);
      const rows = rowsRaw.slice(1);

      const events = [];
      for (const row of rows) {
        const [d, dur, desc, cat, img, chars, locs] = [
          (row[0] || '').trim(), (row[1] || '').trim(),
          (row[2] || '').trim(), (row[3] || '').trim(),
          (row[4] || '').trim(), (row[5] || '').trim(),
          (row[6] || '').trim()
        ];
        if (!d && !dur && !desc && !cat && !img && !chars && !locs) continue;
        const durationWeeks = parseRelWeeks(dur);
        if (!durationWeeks) continue;
        if (!isSpecificWeek(d) && parseRelWeeks(d) == null) continue;

        const characters = (chars ? chars.split(',').map(s => s.trim()).filter(Boolean) : []);
        const location = (locs || '').trim();
        const categoryId = toCatId(cat);
        events.push({ rawDate: d, durationWeeks, desc, categoryId, imageName: img || '', characters, location });
      }
      if (!events.length) throw new Error('No valid events found');
      return { title, events };
    }

    function resolveTimelineDays(tl) {
      // State machine per timeline
      let prevEnd = null;          // previous event's exclusive end dayIdx
      let bundleDay = null;        // current bundle day (for "." starts)
      const dayHasWhole = new Map();   // dayIdx -> true if a whole-day/multi-day start occupies the day
      const byStartDayTemp = new Map(); // temp collection to detect and repair conflicts

      // First pass: compute intended starts & durations (without final repairs)
      const staged = [];
      for (const ev of (tl.events || [])) {
        const startRaw = (ev.rawDate || '').trim();
        const durRaw   = (ev.rawDuration || '').trim();

        // --- Resolve duration
        let { days: durationDays, isSlice } = parseDuration(durRaw);

        // --- Resolve start day (intended) ---
        let startIdx = null;

        if (isSpecificWeekDay(startRaw)) {
          const [Y, W, D] = startRaw.split('-').map(Number);
          const base = isoWeekToDayIdx(`${Y}-${String(W).padStart(2, '0')}`);
          startIdx = base + (D - 1);
          bundleDay = null; // absolute start closes bundles
        } else if (isSpecificWeek(startRaw)) {
          startIdx = isoWeekToDayIdx(startRaw);
          bundleDay = null;
        } else if (isZeroStart(startRaw)) {
          // next day after previous END
          startIdx = (prevEnd == null) ? 0 : (prevEnd);
          bundleDay = null;
        } else if (isSameDayStart(startRaw)) {
          // same-day start: must anchor to an open bundle; otherwise fall forward to next day
          if (bundleDay != null) {
            startIdx = bundleDay;
          } else {
            startIdx = (prevEnd == null) ? 0 : prevEnd; // "no bundle starter" -> behave like 0
            bundleDay = startIdx;
          }
        } else {
          // Relative "#w" or "#d" from previous END
          const relW = parseRelWeeks(startRaw);
          const relD = parseRelDays(startRaw);
          if (relW != null) {
            startIdx = (prevEnd == null) ? relW * 7 : (prevEnd + relW * 7);
            bundleDay = null;
          } else if (relD != null) {
            startIdx = (prevEnd == null) ? relD : (prevEnd + relD);
            bundleDay = null;
          } else {
            // invalid: skip
            continue;
          }
        }

        // Coercions based on rules:
        // - Same-day start with multi-day duration is invalid -> coerce to slice (1d)
        if (isSameDayStart(startRaw) && durationDays > 1) {
          isSlice = true;
          durationDays = 1;
        }

        // - Any "slice" is exactly 1 day
        if (isSlice) durationDays = 1;

        if (isSlice) {
          bundleDay = startIdx;
        } else {
          // Non-slices reset the anchor so a later ". | ." won’t stick to the past day.
          bundleDay = null;
        }

        const endIdx = startIdx + Math.max(1, durationDays);
        prevEnd = endIdx;

        // Stash for the second pass (conflict repair)
        staged.push({
          ...ev,
          startIdx,
          durationDays: Math.max(1, durationDays),
          isSlice
        });

        // Track intended day usage
        if (!isSlice) {
          dayHasWhole.set(startIdx, true);
        }
        if (!byStartDayTemp.has(startIdx)) byStartDayTemp.set(startIdx, []);
        byStartDayTemp.get(startIdx).push(staged[staged.length - 1]);
      }

      // Second pass: repair conflicts
      // Rule: a day cannot mix whole-day starts and bundle slices.
      for (const [d, list] of byStartDayTemp.entries()) {
        const hasWhole = list.some(e => !e.isSlice);
        const hasSlice = list.some(e => e.isSlice);
        if (hasWhole && hasSlice) {
          // Strict repair: move slices to the next day (as if "0 | .")
          for (const e of list) {
            if (e.isSlice) {
              e.startIdx = d + 1;
              // update prevEnd doesn't matter here; we only move intended start
            }
          }
        }
      }

      // Third pass: regroup to re-open bundleDay anchors (visual order stays editor order)
      const normalized = staged.map(e => ({ ...e }));

      // Optional: ensure all slices sharing a day are consecutive in visual order (editor order already preserves it)

      return {
        title: tl.title,
        imageName: tl.imageName || '',
        events: normalized
      };
    }



    /** ============ DAY-LEVEL HELPERS (canonical) ============ **/
    const MS_PER_DAY = 24 * 3600 * 1000;
    // Epoch Monday for ISO weeks
    const EPOCH_MON = new Date(Date.UTC(1970, 0, 5)); // Monday 1970-01-05

    // Monday (00:00 UTC) of ISO week "YYYY-WW"
    function isoWeekToDate(iso) {
      const [yStr, wStr] = String(iso).split('-');
      const Y = +yStr, W = +wStr;
      const jan4 = new Date(Date.UTC(Y, 0, 4));
      const d = jan4.getUTCDay() || 7; // 1..7
      const monW1 = new Date(jan4);
      monW1.setUTCDate(jan4.getUTCDate() - (d - 1)); // Monday of week 1
      const monW = new Date(monW1);
      monW.setUTCDate(monW1.getUTCDate() + (W - 1) * 7);
      monW.setUTCHours(0, 0, 0, 0);
      return monW;
    }

    function dateToDayIdx(d) {
      return Math.floor((d.getTime() - EPOCH_MON.getTime()) / MS_PER_DAY);
    }
    function dayIdxToDate(idx) {
      const d = new Date(EPOCH_MON);
      d.setUTCDate(EPOCH_MON.getUTCDate() + idx);
      d.setUTCHours(0, 0, 0, 0);
      return d;
    }

    // "YYYY-WW" -> Monday dayIdx
    function isoWeekToDayIdx(iso) {
      return dateToDayIdx(isoWeekToDate(iso));
    }

    // dayIdx -> ISO { year, week, day: 1..7 }
    function idxToISODay(idx) {
      const d = dayIdxToDate(idx);
      const day = d.getUTCDay() || 7;     // 1..7
      const th  = new Date(d);            // Thursday of this week
      th.setUTCDate(d.getUTCDate() + (4 - day));
      const isoYear = th.getUTCFullYear();
      const w1 = new Date(Date.UTC(isoYear, 0, 4));
      const wd = (w1.getUTCDay() || 7);
      const w1Mon = new Date(w1);
      w1Mon.setUTCDate(w1.getUTCDate() - (wd - 1));
      const week = 1 + Math.floor((d - w1Mon) / MS_PER_DAY / 7);
      return { year: isoYear, week, day };
    }



    function setupCornerYearTrackerHorizontal(grid, corner) {
      if (!grid || !corner) return;
      const scroller = grid.parentElement;
      if (!scroller) return;

      // ---- Ensure only ONE active set of listeners per scroller ----
      // Abort any previous tracker listeners (from prior renders)
      if (scroller._yearTracker) {
        scroller._yearTracker.abort();
      }
      const controller = new AbortController();
      scroller._yearTracker = controller;

      const getNamesColWidthPx = () => {
        const v = getComputedStyle(grid).getPropertyValue('--names-col-width') || '';
        const n = parseFloat(v);
        return Number.isFinite(n) ? n : 0;
      };

      // Cache the last “good” header so brief gaps don’t blank the year
      let lastHeader = null;

      const headerMidY = () => {
        const any = grid.querySelector('.wlabel');
        if (!any) return 0;
        const r = any.getBoundingClientRect();
        return r.top + r.height / 2;
      };

      const pickHeaderAt = (x, y) => {
        const stack = (document.elementsFromPoint?.(x, y) || []);
        for (const el of stack) {
          if (el.classList?.contains('wlabel')) return el;
        }
        const all = grid.querySelectorAll('.wlabel');
        // Find any header whose rect contains x,y (covers small gaps)
        for (const h of all) {
          const r = h.getBoundingClientRect();
          if (x >= r.left && x < r.right && y >= r.top && y < r.bottom) return h;
        }
        // Fall back to last good header (prevents flashing)
        return lastHeader || all[0] || null;
      };

      const yearFromHeader = (h) => {
        if (!h) return '';
        if (h.dataset.year) return h.dataset.year; // fast path
        if (h.dataset.dayIdx) {
          const d = parseInt(h.dataset.dayIdx, 10);
          if (Number.isFinite(d)) return String(idxToISODay(d).year);
        }
        const prevDay = h.previousElementSibling?.closest?.('.wlabel[data-day-idx]') ||
                        h.parentElement?.querySelector?.('.wlabel[data-day-idx]');
        if (prevDay?.dataset.dayIdx) {
          const d2 = parseInt(prevDay.dataset.dayIdx, 10);
          if (Number.isFinite(d2)) return String(idxToISODay(d2).year);
        }
        return '';
      };

      const update = () => {
        const x = scroller.getBoundingClientRect().left + getNamesColWidthPx() + 1;
        const y = headerMidY();
        const header = y ? pickHeaderAt(x, y) : grid.querySelector('.wlabel');
        if (header) lastHeader = header;
        const yr = yearFromHeader(header);
        // Only touch the DOM if the year actually changes
        if (yr && corner.textContent !== yr) corner.textContent = yr;
      };

      // ----- Initialize once BEFORE listeners (prevents default flash) -----
      update();

      // Keep in sync (with automatic cleanup on next re-render)
      scroller.addEventListener('scroll', update, { passive: true, signal: controller.signal });
      window.addEventListener('resize', update, { signal: controller.signal });

      // Extra robustness for late layout/asset loads
      requestAnimationFrame(update);
      requestAnimationFrame(() => requestAnimationFrame(update));
    }

    function coerceCombinedJson(json) {
      // Accept legacy { timelines, seasonal } or new { settings, timelines, seasonal }
      const out = {
        settings: structuredClone(DEFAULT_SETTINGS),
        timelines: [],
        seasonal: []
      };

      if (!json || typeof json !== 'object') return out;

      // Settings can be nested or (legacy) on root
      const srcSettings = json.settings || {
        ui: json.ui,
        categories: json.categories
      };

      if (srcSettings) {
        const ui = srcSettings.ui || {};
        out.settings.ui = {
          title: String(ui.title || DEFAULT_UI.title),
          theme: ui.theme === 'dark' ? 'dark' : 'light'
        };

        const cats = Array.isArray(srcSettings.categories) ? srcSettings.categories : DEFAULT_SETTINGS.categories;
        out.settings.categories = cats
          .filter(c => Number.isInteger(c.id) && c.id >= 1 && c.id <= 12)
          .map(c => ({
            id: c.id,
            name: String(c.name || ''),
            color: normalizeHexColor(c.color),
            text: String(c.text || '').toLowerCase() === 'white' ? 'white' : 'black'
          }));
      }

      out.timelines = Array.isArray(json.timelines) ? json.timelines : [];
      out.seasonal  = Array.isArray(json.seasonal) ? json.seasonal : [];
      return out;
    }

    /** Editor Helpers **/
    function renderHeaderActions() {
      const host = document.getElementById('ed-actions');
      if (!host) return;
      host.innerHTML = `
        <button id="ed-import" class="ghost" type="button">Import timelines.json</button>
        <button id="ed-download" type="button">Download timelines.json</button>
      `;
      document.getElementById('ed-import').onclick = onImportJSON;
      document.getElementById('ed-download').onclick = onDownloadJSON;
    }

    /** ===================== EDITOR (BASIC) ===================== **/
    let editorState = null;
    let editMode = false;

    function renderEditorUI() {
      const root = document.createElement('div');
      root.id = 'editor';
      root.innerHTML = `
        <div class="editor__backdrop" role="presentation"></div>
        <div class="editor__panel" role="dialog" aria-modal="true" aria-label="Timeline editor">
          <div class="editor__head">
            <div class="editor__title">Timeline Editor</div>
            <div class="editor__actions">
              <span id="ed-actions"></span>
              <button id="ed-close" type="button">Close</button>
            </div>
          </div>
          <div class="editor__body">
            <aside class="editor__sidebar" id="ed-sidebar"></aside>
            <main class="editor__main" id="ed-main"></main>
          </div>
        </div>
      `;
      document.body.appendChild(root);

      document.getElementById('ed-close').onclick = exitEditMode;

      renderSidebar();
      ensureSelectedPane();
      renderMain();
      renderHeaderActions();
    }

    function enterEditMode() { editMode = true; document.body.classList.add('editing'); renderEditorUI(); }
    function exitEditMode() { editMode = false; document.body.classList.remove('editing'); const panel = document.getElementById('editor'); if (panel) panel.remove(); }

    /* debouncedApply with flush() */
    function debounce(fn, ms) {
      let t, lastArgs, lastThis;
      const d = function (...a) {
        lastArgs = a; lastThis = this;
        clearTimeout(t);
        t = setTimeout(() => { t = null; fn.apply(lastThis, lastArgs); }, ms);
      };
      d.flush = () => {
        if (t) { clearTimeout(t); t = null; fn.apply(lastThis, lastArgs); }
      };
      return d;
    }
    const AUTOSAVE_MS = 400;
    const debouncedApply = debounce(() => { applyStateToRenderer(); }, AUTOSAVE_MS);

    /* Force-commit any focused input and flush pending debounce */
    function flushPendingEdits() {
      const ae = document.activeElement;
      if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable)) {
        ae.dispatchEvent(new Event('input',  { bubbles: true }));
        ae.dispatchEvent(new Event('change', { bubbles: true }));
        ae.blur();
      }
      debouncedApply.flush?.();
    }

    /* Use renderer from current in-memory editorState + settingsState */
    async function applyStateToRenderer() {
      const timelines = (editorState?.timelines || []).map(tl => ({
        title: tl.title,
        imageName: tl.image || '',
        events: (tl.events || []).map(e => {
          const categoryId = toCatId(e.categoryId ?? e.category ?? '');
          return {
            rawDate:     e.date,
            rawDuration: e.duration,
            desc:        e.desc,
            categoryId,
            imageName:   e.image || '',
            characters:  Array.isArray(e.characters) ? e.characters : [],
            location:    String(e.location || '')
          };
        })

      }));

      const resolved = timelines.map(resolveTimelineDays);

      // Map seasonal → day indices
      const seasonalMarkers = (editorState?.seasonal || []).map(s => {
        if (isSpecificWeek(s.date)) {
          return { type: 'static', dayIdx: isoWeekToDayIdx(s.date), id: s.id, name: s.name, desc: s.desc || '', imageName: s.id };
        } else if (/^\d{2}$/.test(s.date)) {
          return { type: 'recurring', week: parseInt(s.date, 10), id: s.id, name: s.name, desc: s.desc || '', imageName: s.id };
        }
        return null;
      }).filter(Boolean);

      await renderGridHorizontalDays(resolved, seasonalMarkers);
    }


    /** ===== Selection state ===== */
    let selPane = null;

    function ensureSelectedPane() {
      if (!selPane) return;
      if (selPane.type === 'timeline') {
        const L = editorState?.timelines?.length ?? 0;
        if (!(Number.isInteger(selPane.idx) && selPane.idx >= 0 && selPane.idx < L)) selPane = null;
      } else if (!['world-static','world-recurring','settings'].includes(selPane.type)) {
        selPane = null;
      }
    }

    /** ===== Sidebar ===== */
    function renderSidebar() {
      const host = document.getElementById('ed-sidebar');
      if (!host) return;  // <--- add this guard
      host.innerHTML = '';

      // ===== SETTINGS =====
      const settingsHead = document.createElement('div');
      settingsHead.className = 'ed-main-head';
      settingsHead.innerHTML = `<div><strong>Settings</strong></div>`;
      host.appendChild(settingsHead);

      const settingsRow = document.createElement('div');
      settingsRow.className = 'ed-tl';
      settingsRow.innerHTML = `
        <button class="ghost select-settings" title="Open settings" type="button">●</button>
        <div class="ed-timelines">
          <div class="ed-tl__title">Settings</div>
        </div>`;
      host.appendChild(settingsRow);

      settingsRow.classList.toggle('is-active', selPane?.type === 'settings');
      settingsRow.querySelector('.select-settings').onclick = () => {
        selPane = { type: 'settings' };
        renderSidebar(); renderMain(); renderHeaderActions();
      };

      // ===== WORLD EVENTS =====
      const worldHead = document.createElement('div');
      worldHead.className = 'ed-main-head';
      worldHead.innerHTML = `<div><strong>World Events</strong></div>`;
      host.appendChild(worldHead);

      const worldList = document.createElement('div');
      worldList.className = 'ed-tl-list';
      host.appendChild(worldList);

      const rowStatic = document.createElement('div');
      rowStatic.className = 'ed-tl';
      rowStatic.innerHTML = `
        <button class="ghost select-world" data-kind="world-static" title="Select">●</button>
        <div class="ed-timelines">
          <div class="ed-tl__title">One-off Events</div>
          <div class="ed-tl__meta">Static (YYYY-WW)</div>
        </div>`;
      worldList.appendChild(rowStatic);

      const rowRecurring = document.createElement('div');
      rowRecurring.className = 'ed-tl';
      rowRecurring.innerHTML = `
        <button class="ghost select-world" data-kind="world-recurring" title="Select">●</button>
        <div class="ed-timelines">
          <div class="ed-tl__title">Recurring Events</div>
          <div class="ed-tl__meta">Annual (WW)</div>
        </div>`;
      worldList.appendChild(rowRecurring);

      rowStatic.classList.toggle('is-active', selPane?.type === 'world-static');
      rowRecurring.classList.toggle('is-active', selPane?.type === 'world-recurring');

      rowStatic.querySelector('.select-world').onclick = () => { selPane = { type: 'world-static' }; renderSidebar(); renderMain(); renderHeaderActions(); };
      rowRecurring.querySelector('.select-world').onclick = () => { selPane = { type: 'world-recurring' }; renderSidebar(); renderMain(); renderHeaderActions(); };

      // ===== TIMELINES =====
      const head = document.createElement('div');
      head.className = 'ed-main-head';
      head.innerHTML = `<div><strong>Timelines</strong></div><div><button id="ed-add-tl" type="button"><b>＋</b></button></div>`;
      host.appendChild(head);

      // single authoritative handler (includes image:"")
      document.getElementById('ed-add-tl').onclick = () => {
        const id = `tl_${Date.now()}`;
        editorState.timelines.push({
          id,
          title: 'New Timeline',
          image: '',
          events: []
        });
        selPane = { type: 'timeline', idx: editorState.timelines.length - 1 };
        debouncedApply(); renderSidebar(); renderMain();
      };

      const list = document.createElement('div');
      list.className = 'ed-tl-list';
      host.appendChild(list);

      (editorState.timelines || []).forEach((tl, i) => {
        const row = document.createElement('div');
        row.className = 'ed-tl';
        row.innerHTML = `
          <button class="ghost select-timeline" title="Select" type="button">●</button>
          <div class="ed-timelines">
            <input type="text" class="ed-tl__title" value="${tl.title || ''}" />
            <div class="ed-tl__meta">${(tl.events||[]).length} events</div>
            <div class="ed-btn-box small">
              <button class="ghost" data-act="up" title="Move up">▲</button>
              <button class="ghost" data-act="down" title="Move down">▼</button>
              <button class="danger" data-act="del" title="Delete timeline">X</button>
            </div>
          </div>`;
        list.appendChild(row);

        row.classList.toggle('is-active', selPane?.type === 'timeline' && selPane.idx === i);
        row.querySelector('.select-timeline').onclick = () => { selPane = { type: 'timeline', idx: i }; renderSidebar(); renderMain(); };

        // commit title on *input* so state updates while typing
        row.querySelector('.ed-tl__title').oninput = (e) => {
          tl.title = e.target.value;
          debouncedApply();
          renderSidebar();           // keep sidebar counts/titles fresh
          renderHeaderActions();
        };

        row.querySelector('[data-act="up"]').onclick = () => {
          if (i>0){
            const a = editorState.timelines[i-1];
            editorState.timelines[i-1] = editorState.timelines[i];
            editorState.timelines[i] = a;
            if (selPane?.type === 'timeline' && selPane.idx === i) selPane.idx = i-1;
            debouncedApply(); renderSidebar(); renderMain();
          }
        };
        row.querySelector('[data-act="down"]').onclick = () => {
          if (i<editorState.timelines.length-1){
            const a = editorState.timelines[i+1];
            editorState.timelines[i+1] = editorState.timelines[i];
            editorState.timelines[i] = a;
            if (selPane?.type === 'timeline' && selPane.idx === i) selPane.idx = i+1;
            debouncedApply(); renderSidebar(); renderMain();
          }
        };
        row.querySelector('[data-act="del"]').onclick = () => {
          if (confirm(`Delete timeline "${tl.title}"?`)){
            editorState.timelines.splice(i,1);
            if (selPane?.type === 'timeline') {
              if (editorState.timelines.length === 0) selPane = null;
              else if (selPane.idx >= editorState.timelines.length) selPane.idx = editorState.timelines.length - 1;
            }
            debouncedApply(); renderSidebar(); renderMain();
          }
        };
      });
    }

    /** ===== Main panel ===== */
    function renderMain() {
      ensureSelectedPane();
      renderHeaderActions();
      const host = document.getElementById('ed-main');
      if (!host) return;  // <--- add this guard
      host.innerHTML = '';

      if (!selPane) {
        host.innerHTML = `
          <div class="ed-main-head"><strong>Nothing selected</strong></div>
          <div class="ed-empty">Choose <em>Settings</em>, <em>One-off Events</em>, <em>Recurring Events</em>, or a <em>Timeline</em> from the left.</div>`;
        return;
      }

      if (selPane.type === 'settings') { renderSettingsEditor(host); return; }
      if (selPane.type === 'world-static' || selPane.type === 'world-recurring') {
        renderWorldEditor(host, selPane.type === 'world-static' ? 'static' : 'recurring'); return;
      }

      if (!editorState.timelines.length) {
        host.innerHTML = '<div class="ed-main-head"><em>No timelines. Add one from the left.</em></div>';
        return;
      }
      const tl = editorState.timelines[selPane.idx];

      const head = document.createElement('div');
      head.className = 'ed-main-head';
      head.innerHTML = `
        <div class="ed-main-titlebar" style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
          <div class="ed-main-title" style="font-weight:700;">${tl.title || 'Untitled'}</div>

          <div class="ed-tl-image" style="display:flex;align-items:center;gap:8px;">
            <div class="ed-thumb ed-thumb--ph" aria-hidden="false" style="width:36px;height:36px;border-radius:6px;background:#f2f2f2;border:1px solid #ddd;"></div>
            <input type="text" id="ed-tl-image-input" value="${tl.image || ''}"
              placeholder="Timeline image slug" title="Timeline Image Slug"
              style="min-width:220px;">
          </div>

          <div class="ed-btn-box" style="margin-left:auto;display:flex;gap:8px;">
            <button id="ed-add-ev" type="button"><b>＋</b></button>
            <button id="ed-dup-evs" class="ghost" type="button">++ All</button>
            <button id="ed-clear-evs" class="danger" type="button">X All</button>
          </div>
        </div>`;
      host.appendChild(head);

      // Wire timeline image preview
      (function () {
        const wrap = head.querySelector('.ed-tl-image');
        const input = head.querySelector('#ed-tl-image-input');

        function updateTlImagePreview() {
          wrap.querySelectorAll('.ed-thumb').forEach(n => n.remove());

          const slug = (input.value || '').trim();
          if (!slug) {
            const ph = document.createElement('div');
            ph.className = 'ed-thumb ed-thumb--ph';
            ph.setAttribute('aria-hidden','false');
            ph.style.cssText = 'width:36px;height:36px;border-radius:6px;background:#f2f2f2;border:1px solid #ddd;';
            wrap.insertBefore(ph, input);
            return;
          }
          const imgEl = makeSmartImgFallback(
            IMAGES_DIR,
            slug,
            'ed-thumb',
            slug,
            () => {
              const ph = document.createElement('div');
              ph.className = 'ed-thumb ed-thumb--ph';
              ph.setAttribute('aria-hidden','false');
              ph.style.cssText = 'width:36px;height:36px;border-radius:6px;background:#f2f2f2;border:1px solid #ddd;';
              wrap.insertBefore(ph, input);
            }
          );
          if (imgEl) {
            imgEl.style.cssText = 'width:36px;height:36px;border-radius:6px;object-fit:cover;border:1px solid #ddd;';
            wrap.insertBefore(imgEl, input);
          }
        }

        updateTlImagePreview();

        input.addEventListener('input', () => {
          tl.image = input.value.trim();
          updateTlImagePreview();
          debouncedApply();
        });
      })();

      const table = document.createElement('table');
      table.className = 'ed-table';
      table.innerHTML = `<tbody></tbody>`;
      host.appendChild(table);

      const tbody = table.querySelector('tbody');
      const evs = tl.events || [];

      evs.slice().reverse().forEach((ev, rIdx) => {
        const i = evs.length - 1 - rIdx;
        ev.categoryId = toCatId(ev.categoryId ?? ev.category ?? '');

        const tr = document.createElement('tr');
        tr.dataset.catId = ev.categoryId || 0;
        const catColor = getCatColor(ev.categoryId);
        tr.dataset.catColor = catColor || '';
        tr.style.setProperty('--jcolor', catColor || 'transparent');
        tr.innerHTML = `
      <td>
        <div class="ed-row-data">
          <div class="ed-row-data-top">
            <input type="text" class="ed-desc" value="${ev.desc || ''}" placeholder="Event Name" title="Event Name">
            <div class="ed-category"></div>
          </div>
          <div class="ed-row-data-bottom">
            <input type="text" class="ed-date" value="${ev.date || ''}" placeholder="Date" title="Date: YYYY-WW or 2w">
            <input type="text" class="ed-duration" value="${ev.duration || ''}" placeholder="Duration" title="Duration: e.g. 3w">
            <input type="text" class="ed-characters" value="${(ev.characters || []).join(', ')}" placeholder="Characters" title="Characters: Comma separated">
            <input type="text" class="ed-location" value="${ev.location || ''}" placeholder="Location"  title="Single location string">
          </div>
        </div>
        <div class="ed-row-btns">
          <div class="ed-image">
            <div class="ed-thumb ed-thumb--ph" aria-hidden="false"></div>
            <input type="text" class="ed-image-input" value="${ev.image || ''}" placeholder="Image slug" title="Image Slug">
          </div>
          <div class="ed-btn-box small">
            <button data-act="up" class="ghost" title="Move up">▲</button>
            <button data-act="down" class="ghost" title="Move down">▼</button>
            <button data-act="dup" class="ghost" title="Duplicate">++</button>
            <button data-act="del" class="danger" title="Delete">X</button>
          </div>
        </div>
      </td>`;
        tbody.appendChild(tr);

        // Category select (from settings)
        const catCell = tr.querySelector('.ed-category');
        const sel = document.createElement('select');
        const cats = [{ id: 0, name: '—' }].concat(settingsState.categories || []);
        sel.innerHTML = cats.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
        sel.value = String(ev.categoryId || 0);
        catCell.appendChild(sel);

        sel.addEventListener('change', e => {
          ev.categoryId = parseInt(e.target.value, 10) || 0;
          tr.dataset.catId = ev.categoryId;
          debouncedApply();
        });

        // inputs
        const iDesc = tr.querySelector('.ed-desc');
        const iDate = tr.querySelector('.ed-date');
        const iDur = tr.querySelector('.ed-duration');
        const iImg = tr.querySelector('.ed-image-input');
        const iCh = tr.querySelector('.ed-characters');
        const iLo = tr.querySelector('.ed-location');
        iLo.addEventListener('input', () => {
          ev.location = (iLo.value || '').trim();
          debouncedApply();
        });

        // image preview
        const imgCell = tr.querySelector('.ed-image');
        function updateImagePreview() {
          imgCell.querySelectorAll('.ed-thumb').forEach(n => n.remove());
          const slug = (iImg.value || '').trim();
          if (!slug) {
            const ph = document.createElement('div');
            ph.className = 'ed-thumb ed-thumb--ph';
            imgCell.insertBefore(ph, iImg);
            return;
          }
          const imgEl = makeSmartImgFallback(IMAGES_DIR, slug, 'ed-thumb', slug, () => {
            const ph = document.createElement('div');
            ph.className = 'ed-thumb ed-thumb--ph';
            imgCell.insertBefore(ph, iImg);
          });
          if (imgEl) imgCell.insertBefore(imgEl, iImg);
        }
        updateImagePreview();

        // bindings
        iDesc.addEventListener('input', () => { ev.desc = iDesc.value; debouncedApply(); });
        iDate.addEventListener('input', () => { ev.date = iDate.value.trim(); debouncedApply(); });
        iDur.addEventListener('input', () => { ev.duration = iDur.value.trim(); debouncedApply(); });
        iImg.addEventListener('input', () => { ev.image = iImg.value.trim(); updateImagePreview(); debouncedApply(); });
        iCh.addEventListener('input', () => { ev.characters = tokenise(iCh.value); debouncedApply(); });
        iLo.addEventListener('input', () => { ev.location = (iLo.value || '').trim(); debouncedApply(); });

        // row actions
        tr.querySelector('[data-act="down"]').onclick = () => { if (i > 0) { const a = evs[i - 1]; evs[i - 1] = evs[i]; evs[i] = a; renderMain(); debouncedApply(); } };
        tr.querySelector('[data-act="up"]').onclick = () => { if (i < evs.length - 1) { const a = evs[i + 1]; evs[i + 1] = evs[i]; evs[i] = a; renderMain(); debouncedApply(); } };
        tr.querySelector('[data-act="dup"]').onclick = () => { evs.splice(i + 1, 0, structuredClone(ev)); renderMain(); debouncedApply(); };
        tr.querySelector('[data-act="del"]').onclick = () => { evs.splice(i, 1); renderMain(); debouncedApply(); };
      });

      // top buttons
      document.getElementById('ed-add-ev').onclick = () => {
        evs.push({ date: '', duration: '1w', desc: '', categoryId: 0, image: '', characters: [], location: '' });
        renderMain(); debouncedApply();
      };
      document.getElementById('ed-dup-evs').onclick = () => {
        tl.events = [...evs.map(e => structuredClone(e)), ...evs.map(e => structuredClone(e))];
        renderMain(); debouncedApply();
      };
      document.getElementById('ed-clear-evs').onclick = () => {
        if (confirm('Remove all events in this timeline?')) { tl.events = []; renderMain(); debouncedApply(); }
      };
    }

    /** ===== Settings editor ===== */
    function renderSettingsEditor(host) {
      const head = document.createElement('div');
      head.className = 'ed-main-head';
      head.innerHTML = `<div><strong>Settings</strong></div>`;
      host.appendChild(head);

      const wrap = document.createElement('div');
      wrap.className = 'ed-sect';
      host.appendChild(wrap);

      // === General
      const uiCard = document.createElement('div');
      uiCard.className = 'ed-sect';
      uiCard.innerHTML = `
        <h3>General</h3>
        <div class="ed-list">
          <div class="ed-row">
            <label style="display:block; font-weight:600; margin-bottom:.25rem;">Title</label>
            <input type="text" id="ui-title" value="${(settingsState.ui?.title) || DEFAULT_UI.title}" placeholder="Site title" />
          </div>

          <div class="ed-row" style="margin-top:12px;">
            <label style="display:block; font-weight:600; margin-bottom:.25rem;">Theme</label>
            <label style="margin-right:1rem;">
              <input type="radio" name="ui-theme" value="light" ${(settingsState.ui?.theme === 'dark') ? '' : 'checked'}>
              Light
            </label>
            <label>
              <input type="radio" name="ui-theme" value="dark" ${(settingsState.ui?.theme === 'dark') ? 'checked' : ''}>
              Dark
            </label>
          </div>

          <div class="ed-row" style="margin-top:12px;">
            <label style="display:block; font-weight:600; margin-bottom:.25rem;">Empty Days</label>
            <label>
              <input type="checkbox" id="ui-collapse"
                ${(settingsState.ui?.collapseEmptyDays ? 'checked' : '')}>
              Collapse empty days (hide days with no events)
            </label>
          </div>
        </div>
      `;
      wrap.appendChild(uiCard);

      const iTitle = uiCard.querySelector('#ui-title');
      iTitle.addEventListener('input', () => {
        if (!settingsState.ui) settingsState.ui = { ...DEFAULT_UI };
        settingsState.ui.title = iTitle.value;
        applyAllFromSettings();
      });

      uiCard.querySelectorAll('input[name="ui-theme"]').forEach(r => {
        r.addEventListener('change', (e) => {
          if (!settingsState.ui) settingsState.ui = { ...DEFAULT_UI };
          settingsState.ui.theme = e.target.value === 'dark' ? 'dark' : 'light';
          applyAllFromSettings();
        });
      });

      const iCollapse = uiCard.querySelector('#ui-collapse');
      iCollapse.addEventListener('change', () => {
        if (!settingsState.ui) settingsState.ui = { ...DEFAULT_UI };
        settingsState.ui.collapseEmptyDays = !!iCollapse.checked;
        applyAllFromSettings();
      });

      // === Categories
      const table = document.createElement('table');
      table.className = 'ed-table';
      table.innerHTML = `
        <thead>
          <tr>
            <th style="width:70px;">ID</th>
            <th>Name</th>
            <th style="width:160px;">Color</th>
            <th style="width:90px;">Inner Text</th>
          </tr>
        </thead>
        <tbody></tbody>`;
      wrap.appendChild(table);

      const tbody = table.querySelector('tbody');

      (settingsState.categories || []).slice().sort((a,b)=>a.id-b.id).forEach(cat => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td><code>${cat.id}</code></td>
          <td><input type="text" class="cat-name" value="${cat.name}" placeholder="Category ${cat.id}" /></td>
          <td>
            <div style="display:flex; align-items:center; gap:.5rem;">
              <input type="color" class="cat-color-picker" value="${toColorInputValue(cat.color)}" />
              <input type="text" class="cat-color" value="${cat.color || ''}" placeholder="#RRGGBB" />
            </div>
          </td>
          <td>
            <button type="button" class="cat-text-toggle"
              title="Toggle text color (black/white)"
              style="width:40px;height:26px;border:1px solid #ccc;border-radius:4px;
                    background:${cat.color || 'transparent'};
                    color:${cat.text === 'white' ? '#fff' : '#000'};">
              A
            </button>
          </td>
        `;
        tbody.appendChild(tr);

        const iName = tr.querySelector('.cat-name');
        const iColorText   = tr.querySelector('.cat-color');
        const iColorPicker = tr.querySelector('.cat-color-picker');
        const textBtn      = tr.querySelector('.cat-text-toggle');

        iName.addEventListener('input', () => { cat.name = iName.value; applyStateToRenderer(); });

        // Text field -> model + picker + swatch
        iColorText.addEventListener('input', () => {
          const raw = iColorText.value;
          const norm = normalizeHexColor(raw); // '' if invalid
          if (raw.trim() === '' || norm) {
            cat.color = norm; // '' clears color
            textBtn.style.background = norm || 'transparent';
            textBtn.style.background = norm || 'transparent';
            if (norm) iColorPicker.value = toColorInputValue(norm);
            applyStateToRenderer();
          }
        });

        // Picker ➜ Text
        iColorPicker.addEventListener('input', () => {
          const val = iColorPicker.value;              // always #RRGGBB
          const norm = normalizeHexColor(val);         // stays #rrggbb with '#'
          cat.color = norm;
          iColorText.value = norm;
          textBtn.style.background = norm || 'transparent';
          textBtn.style.background = norm || 'transparent';
          applyStateToRenderer();
        });

        // Text ➜ Picker (NEW)
        iColorText.addEventListener('input', () => {
          const raw  = iColorText.value.trim();
          if (raw === '') {
            // allow clearing
            cat.color = '';
            textBtn.style.background = 'transparent';
            // don't force-set the picker; leave last chosen color visible
            applyStateToRenderer();
            return;
          }

          const norm = normalizeHexColor(raw); // accepts #RGB/#RGBA/#RRGGBB/#RRGGBBAA
          if (!norm) {
            // invalid so far — do nothing (user might still be typing)
            return;
          }

          // commit normalized value back to text (nice & consistent)
          iColorText.value = norm.toUpperCase();
          cat.color = norm;

          // update the picker (must be #RRGGBB)
          iColorPicker.value = toColorInputValue(norm);

          // live preview on the toggle button
          textBtn.style.background = norm || 'transparent';

          applyStateToRenderer();
        });

        textBtn.addEventListener('click', () => {
          cat.text = (cat.text === 'white') ? 'black' : 'white';
          textBtn.style.color = (cat.text === 'white') ? '#fff' : '#000';
          applyStateToRenderer();
        });
      });
    }

    /** ===== World Events editor ===== */
    function renderWorldEditor(host, kind) {
      const isStatic = (kind === 'static');
      const title = isStatic ? 'One-off Events' : 'Recurring Events';
      const placeholder = isStatic ? 'YYYY-WW' : 'WW';

      const head = document.createElement('div');
      head.className = 'ed-main-head';
      head.innerHTML = `
        <div><strong>${title}</strong></div>
        <div class="ed-btn-box">
          <button id="ed-add-world" type="button"><b>＋</b></button>
        </div>`;
      host.appendChild(head);

      const wrap = document.createElement('div');
      wrap.className = 'ed-sect';
      host.appendChild(wrap);

      const list = document.createElement('div');
      list.className = 'ed-list';
      wrap.appendChild(list);

      const items = (editorState.seasonal || []).filter(s => {
        const isS = /^\d{4}-\d{2}$/.test(s.date);
        return isStatic ? isS : !isS;
      });

      items.forEach((s) => {
        const row = document.createElement('div');
        row.className = 'ed-sea';
        row.innerHTML = `
      <div class="ed-row-data-top">
        <input type="text" class="ed-sea-name" value="${s.name}" title="Event Name" placeholder="Event Name">
        <input type="text" class="ed-sea-date" value="${s.date}" placeholder="${placeholder}" title="Date: ${placeholder}">
      </div>
      <input type="text" class="ed-sea-desc" value="${s.desc || ''}" title="Event Description" placeholder="Event Description">
      <div class="ed-row-data-bottom">
        <div class="ed-sea-image">
          <div class="ed-thumb ed-thumb--ph" aria-hidden="false"></div>
          <input type="text" class="ed-sea-id" value="${s.id}" title="Image Slug" placeholder="Image Slug">
        </div>
        <div class="ed-btn-box small">
          <button data-act="up" class="ghost">▲</button>
          <button data-act="down" class="ghost">▼</button>
          <button data-act="del" class="danger">🞬</button>
        </div>
      </div>`;
        list.appendChild(row);

        const iName = row.querySelector('.ed-sea-name');
        const iId = row.querySelector('.ed-sea-id');
        const iDesc = row.querySelector('.ed-sea-desc');
        const iDate = row.querySelector('.ed-sea-date');
        const imgWrap = row.querySelector('.ed-sea-image');

        function updateSeasonalPreview() {
          imgWrap.querySelectorAll('.ed-thumb').forEach(n => n.remove());
          const slug = (iId.value || '').trim();
          if (!slug) { const ph = document.createElement('div'); ph.className = 'ed-thumb ed-thumb--ph'; ph.setAttribute('aria-hidden','false'); imgWrap.insertBefore(ph, iId); return; }
          const imgEl = makeSmartImgFallback(IMAGES_DIR, slug, 'ed-thumb', slug, () => {
            const ph = document.createElement('div'); ph.className = 'ed-thumb ed-thumb--ph'; ph.setAttribute('aria-hidden','false'); imgWrap.insertBefore(ph, iId);
          });
          if (imgEl) imgWrap.insertBefore(imgEl, iId);
        }
        updateSeasonalPreview();

        iName.addEventListener('input', () => { s.name = iName.value; debouncedApply(); });
        iId.addEventListener('input', () => { s.id = iId.value.trim(); updateSeasonalPreview(); debouncedApply(); });
        iDesc.addEventListener('input', () => { s.desc = iDesc.value; debouncedApply(); });
        iDate.addEventListener('input', () => { s.date = iDate.value.trim(); debouncedApply(); });

        row.querySelector('[data-act="up"]').onclick = () => {
          const arr = editorState.seasonal || [];
          const idx = arr.indexOf(s);
          if (idx > 0) { const a = arr[idx - 1]; arr[idx - 1] = arr[idx]; arr[idx] = a; renderMain(); debouncedApply(); }
        };
        row.querySelector('[data-act="down"]').onclick = () => {
          const arr = editorState.seasonal || [];
          const idx = arr.indexOf(s);
          if (idx < arr.length - 1) { const a = arr[idx + 1]; arr[idx + 1] = arr[idx]; arr[idx] = a; renderMain(); debouncedApply(); }
        };
        row.querySelector('[data-act="del"]').onclick = () => {
          const arr = editorState.seasonal || [];
          const idx = arr.indexOf(s);
          if (idx >= 0) { arr.splice(idx, 1); renderMain(); debouncedApply(); }
        };
      });

      document.getElementById('ed-add-world').onclick = () => {
        if (!editorState.seasonal) editorState.seasonal = [];
        editorState.seasonal.push(
          isStatic
            ? { date: `${new Date().getUTCFullYear()}-01`, id: 'season', name: 'Event', desc: '' }
            : { date: '01', id: 'season', name: 'Event', desc: '' }
        );
        renderMain(); debouncedApply();
      };
    }

    function getCatColor(id) { return getCatById(id)?.color || ''; }

    function tokenise(s) {
      if (!s) return [];
      return [...new Set(s.split(',').map(x => x.trim()).filter(Boolean))];
    }

    /** ===================== Persistence actions ===== */
    function onDownloadJSON() {
      flushPendingEdits(); // keep this to commit in-flight inputs

      const combined = {
        settings: settingsState || DEFAULT_SETTINGS,
        timelines: normalizeEditorState(structuredClone(editorState)).timelines || [],
        seasonal:  normalizeEditorState(structuredClone(editorState)).seasonal  || []
      };

      const blob = new Blob([JSON.stringify(combined, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'timelines.json';
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(a.href);
      a.remove();
    }



    async function onImportJSON() {
      const inp = document.createElement('input');
      inp.type = 'file'; inp.accept = '.json,application/json';
      inp.onchange = async () => {
        const file = inp.files[0]; if (!file) return;
        try {
          const text = await file.text();
          const raw  = JSON.parse(text);
          const combined = coerceCombinedJson(raw);

          settingsState = combined.settings || DEFAULT_SETTINGS;
          editorState   = normalizeEditorState({
            timelines: combined.timelines || [],
            seasonal:  combined.seasonal  || []
          });

          applyAllFromSettings();      // applies UI + renderer
          renderSidebar(); renderMain();
        } catch (e) {
          alert('Failed to import: ' + (e.message || e));
        }
      };
      inp.click();
    }



    /** ===================== RENDER TIMELINES (Horizontal) ===================== **/
    async function renderGridHorizontalDays(timelines, seasonalMarkers = []) {
      const grid = $('grid');
      grid.innerHTML = '';

      // ---- bounds (defensive for empty data) ----
      const eventBounds = timelines.flatMap(tl => tl.events.map(ev => [ev.startIdx, ev.startIdx + ev.durationDays]));
      const hasAnyEvents = eventBounds.length > 0;
      const minIdx = hasAnyEvents ? Math.min(...eventBounds.map(b => b[0])) : 0;
      const maxIdx = hasAnyEvents ? Math.max(...eventBounds.map(b => b[1])) : 1; // exclusive
      const totalDays = Math.max(1, maxIdx - minIdx);

      // ---- expand seasonal (map to Monday of week) ----
      const { year: minYear } = idxToISODay(minIdx);
      const { year: maxYear } = idxToISODay(maxIdx - 1);
      const expandedSeasonal = [];
      for (const m of seasonalMarkers) {
        if (m.type === 'static') expandedSeasonal.push(m);
        else if (m.type === 'recurring') {
          const ww = String(m.week).padStart(2, '0');
          for (let y = minYear; y <= maxYear; y++) {
            const dayIdx = isoWeekToDayIdx(`${y}-${ww}`);
            if (dayIdx >= minIdx && dayIdx < maxIdx) {
              expandedSeasonal.push({ ...m, type: 'static', dayIdx });
            }
          }
        }
      }
      const seasonalByDay = new Map();
      for (const m of expandedSeasonal) {
        if (!seasonalByDay.has(m.dayIdx)) seasonalByDay.set(m.dayIdx, []);
        seasonalByDay.get(m.dayIdx).push(m);
      }

      // ---- active days from events ----
      const activeDayCounts = new Map();
      for (const tl of timelines) for (const ev of tl.events) {
        const a = Math.min(ev.startIdx, ev.startIdx + ev.durationDays);
        const b = Math.max(ev.startIdx, ev.startIdx + ev.durationDays);
        for (let i = a; i < b; i++) activeDayCounts.set(i, (activeDayCounts.get(i) || 0) + 1);
      }
      const eventDaysSet = new Set([...activeDayCounts.keys()]);

      // ---- collapse logic ----
      const collapse = !!settingsState?.ui?.collapseEmptyDays;

      // When collapsed: only “day columns” for days with events; seasonal columns always show where present.
      // When NOT collapsed: create a day column for *every* day from [minIdx, maxIdx), plus seasonal columns where present.
      const allDays = [];
      for (let d = minIdx; d < maxIdx; d++) allDays.push(d);

      const columns = [];
      const dayColIndex = new Map(); // maps dayIdx -> column index for the "day" column
      for (const d of allDays) {
        // seasonal columns always (if present)
        const seas = seasonalByDay.get(d);
        if (seas && seas.length) {
          for (const m of seas) columns.push({ type: 'seasonal', dayIdx: d, data: m });
        }

        // decide if we add a "day" column
        const addDay =
          collapse ? eventDaysSet.has(d) : true; // collapsed => only event days; expanded => all days

        if (addDay) {
          dayColIndex.set(d, columns.length);
          columns.push({ type: 'day', dayIdx: d });
        }
      }

      // --- Build bundles: timelineIndex -> Map(dayIdx -> array of slice events) ---
      const bundlesByTl = timelines.map(() => new Map());
      for (let r = 0; r < timelines.length; r++) {
        const tl = timelines[r];
        const map = bundlesByTl[r];
        for (const ev of tl.events) {
          if (ev.isSlice && ev.durationDays === 1) {
            const d = ev.startIdx;
            if (!map.has(d)) map.set(d, []);
            map.get(d).push(ev);
          }
        }
        // Keep deterministic ordering: editor order => left-to-right
        for (const arr of map.values()) {
          // If you ever add explicit "sequence", you can sort by it here
          // arr.sort((a,b)=> (a.sequence??0)-(b.sequence??0));
        }
      }


      // ---- grid templates ----
      grid.style.gridTemplateRows = [
        'var(--week-header-row)', // week band
        'var(--week-header-row)', // day headers
        ...timelines.map(() => 'minmax(var(--timeline-row-min), auto)')
      ].join(' ');

      grid.style.gridTemplateColumns = [
        'var(--names-col-width)',
        ...columns.map(() => 'var(--week-col-width)')
      ].join(' ');

      // ---- corner (top-left) ----
      const corner = document.createElement('div');
      corner.className = 'corner';
      corner.style.gridRow = '1 / 3';
      corner.style.gridColumn = '1 / 2';
      corner.textContent = '';
      grid.appendChild(corner);

      // ---- row 2: day + seasonal headers ----
      columns.forEach((col, c) => {
        const gridCol = 2 + c;
        if (col.type === 'day') {
          const hdr = document.createElement('div');
          hdr.className = 'wlabel';
          hdr.dataset.dayIdx = String(col.dayIdx);

          const { year, day } = idxToISODay(col.dayIdx);   // <- week no longer needed here
          hdr.dataset.year = String(year);

          const dname = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'][day - 1];
          const dt = dayIdxToDate(col.dayIdx);
          const dd = String(dt.getUTCDate()).padStart(2, '0');

          const inner = document.createElement('div');
          inner.className = 'wlabel__inner';
          inner.textContent = `${dname} ${dd}`;
          const count = activeDayCounts.get(col.dayIdx) || 0;
          if (count > 0) { inner.classList.add('has-events'); inner.dataset.count = String(count); }

          hdr.appendChild(inner);
          hdr.style.gridRow = '2 / 3';
          hdr.style.gridColumn = `${gridCol} / ${gridCol + 1}`;
          grid.appendChild(hdr);
        }
 else {
          const hdr = document.createElement('div');
          hdr.className = 'wlabel wlabel--seasonal';
          hdr.dataset.dayIdx = String(col.dayIdx);

          const { year } = idxToISODay(col.dayIdx);
          hdr.dataset.year = String(year);

          const inner = document.createElement('div');
          inner.className = 'wlabel__inner wlabel__inner--seasonal';

          const m = col.data;
          const img = makeSmartImg(IMAGES_DIR, m.imageName, 'seasonal-thumb', m.name);
          if (img) inner.appendChild(img);

          const nameEl = document.createElement('span');
          nameEl.className = 'seasonal-name';
          nameEl.textContent = m.name;
          inner.appendChild(nameEl);

          if (m.desc) {
            const descEl = document.createElement('span');
            descEl.className = 'seasonal-desc';
            descEl.textContent = m.desc;
            inner.appendChild(descEl);
          }

          hdr.appendChild(inner);
          hdr.style.gridRow = '2 / 3';
          hdr.style.gridColumn = `${gridCol} / ${gridCol + 1}`;
          grid.appendChild(hdr);
        }
      });

      // ---- row 1: Week bands spanning the columns present for that week ----
      const firstMonday = isoWeekToDayIdx(`${idxToISODay(minIdx).year}-${String(idxToISODay(minIdx).week).padStart(2,'0')}`);
      let wkStart = firstMonday;
      while (wkStart < maxIdx) {
        const wkEnd = wkStart + 7;
        const dayStart = Math.max(wkStart, minIdx);
        const dayEnd   = Math.min(wkEnd,   maxIdx);

        let spanCols = 0;
        let colStart = null;

        for (let d = dayStart; d < dayEnd; d++) {
          const seas = seasonalByDay.get(d)?.length || 0;
          const hasDayCol = dayColIndex.has(d); // respects collapse/expanded

          if (seas || hasDayCol) {
            if (colStart == null) {
              // first column index for this block: first seasonal if any, else day col
              if (seas) {
                colStart = 2 + columns.findIndex(c => c.type === 'seasonal' && c.dayIdx === d);
              } else {
                colStart = 2 + dayColIndex.get(d);
              }
            }
            spanCols += seas + (hasDayCol ? 1 : 0);
          }
        }

        if (colStart != null && spanCols > 0) {
          const { year, week } = idxToISODay(wkStart);
          const wkHdr = document.createElement('div');
          wkHdr.className = 'wlabel wlabel--weekband';
          const inner = document.createElement('div');
          inner.className = 'wlabel__inner wlabel__inner--weekband';
          inner.textContent = `Week ${String(week).padStart(2, '0')}`;
          wkHdr.appendChild(inner);
          wkHdr.style.gridRow = '1 / 2';
          wkHdr.style.gridColumn = `${colStart} / ${colStart + spanCols}`;
          wkHdr.dataset.year = String(year);
          grid.appendChild(wkHdr);
        }

        wkStart += 7;
      }

      // ---- precompute timeline ranges ----
      const tlRanges = computeTimelineRanges(timelines);

      // ---- left names column + background cells ----
      timelines.forEach((tl, r) => {
        const gridRow = 3 + r;
        const name = buildTimelineHeaderEl({ title: tl.title, imageName: tl.imageName });
        name.style.gridRow = `${gridRow} / ${gridRow + 1}`;
        name.style.gridColumn = '1 / 2';
        grid.appendChild(name);

        columns.forEach((col, c) => {
          const bg = document.createElement('div');
          bg.className = 'cell' + (col.type === 'seasonal' ? ' cell--seasonal' : '');
          bg.style.gridRow = `${gridRow} / ${gridRow + 1}`;
          bg.style.gridColumn = `${2 + c} / ${3 + c}`;

          const range = tlRanges[r];
          if (typeof col.dayIdx === 'number') {
            if (isOutsideBuffered(range, col.dayIdx, 1)) bg.classList.add('outside');
          } else {
            bg.classList.add('outside');
          }

          grid.appendChild(bg);
        });
      });

      // ---- place events (prev/next run detection; bundles wrap normal .event cards) ----
      for (let r = 0; r < timelines.length; r++) {
        const tl = timelines[r];
        const gridRow = 3 + r;

        // map a day to the visible day column (respects collapsed days)
        const colOfSlice = (ev) => {
          if (!(ev && ev.isSlice && ev.durationDays === 1)) return null;
          return dayColIndex.has(ev.startIdx) ? dayColIndex.get(ev.startIdx) : null;
        };

        // tiny factory for event DOM (same styling as your normal events)
        const buildEventEl = (ev, inBundle, gridColStart, span) => {
          const el = document.createElement('div');
          el.className = 'event';

          const catId   = toCatId(ev.categoryId);
          const catName = getCatName(catId);
          const catColor= getCatColor(catId);
          const catText = getCatText(catId);

          el.dataset.catId    = String(catId || 0);
          el.dataset.catTitle = catName || '';
          el.dataset.catColor = catColor || '';
          el.style.setProperty('--jcolor', catColor || 'transparent');
          el.style.setProperty('--jtext',  catText  || 'black');

          if (!inBundle) {
            el.style.gridRow    = `${gridRow} / ${gridRow + 1}`;
            el.style.gridColumn = `${gridColStart} / ${gridColStart + span}`;
          }

          const { year, week, day } = idxToISODay(ev.startIdx);
          const labelStart = `${year}-${String(week).padStart(2,'0')}-${day}`;

          const topline = document.createElement('div');
          topline.className = 'topline';

          const sticky = document.createElement('div');
          sticky.className = 'event-sticky';
          sticky.dataset.image = 'false';
          prependEventMedia(sticky, ev, (has) => { sticky.dataset.image = has ? 'true' : 'false'; });

          if (catName) {
            const cat = document.createElement('div');
            cat.className = 'cat';
            cat.textContent = catName;
            topline.appendChild(cat);
          }

          const title = document.createElement('div');
          title.className = 'desc';
          title.textContent = ev.desc || '(no description)';
          topline.appendChild(title);

          const meta = document.createElement('div');
          meta.className = 'meta';
          meta.textContent = ev.isSlice ? `${labelStart} • slice` : `${labelStart} • ${ev.durationDays}d`;
          topline.appendChild(meta);

          // combined chips: [location] then [characters]
          {
            const chips = document.createElement('div');
            chips.className = 'chips';

            // location first (single string, no link)
            const loc = (ev.location || '').trim();
            if (loc) {
              const chipLoc = document.createElement('span');
              chipLoc.className = 'chip location';
              chipLoc.title = `Location: ${loc}`;
              chipLoc.textContent = loc;
              chips.appendChild(chipLoc);
            }

            // characters next (plain text, no icons/links)
            if (Array.isArray(ev.characters) && ev.characters.length) {
              for (const n of ev.characters) {
                const name = String(n).trim();
                if (!name) continue;
                const chipChar = document.createElement('span');
                chipChar.className = 'chip character';
                chipChar.title = `Character: ${name}`;
                chipChar.textContent = name;
                chips.appendChild(chipChar);
              }
            }

            // only append if something exists
            if (chips.children.length) {
              topline.appendChild(chips);
            }
          }


          sticky.appendChild(topline);
          el.appendChild(sticky);
          return el;
        };

        // open host state (implicit “close” by clearing this)
        let openHost = null;
        let openCol  = null;

        for (let i = 0; i < tl.events.length; i++) {
          const ev   = tl.events[i];
          const prev = tl.events[i - 1];
          const next = tl.events[i + 1];

          const isSlice = !!(ev && ev.isSlice && ev.durationDays === 1);
          const col     = isSlice ? colOfSlice(ev) : null;

          // If event is a bundle (slice) but its day column is not visible (collapsed), skip it entirely
          if (isSlice && col == null) {
            // If we had an open host for another column, we leave it open until a non-slice or a different column closes it
            continue;
          }

          // ---- bundle open/close logic (exactly your flow) ----
          if (isSlice) {
            const prevIsSameBundle = !!(prev && prev.isSlice && prev.durationDays === 1 && colOfSlice(prev) === col);
            const nextIsSameBundle = !!(next && next.isSlice && next.durationDays === 1 && colOfSlice(next) === col);

            // OPEN if previous is NOT a bundle in the same column
            if (!prevIsSameBundle) {
              const gridColStart = 2 + col;
              openHost = document.createElement('div');
              openHost.className = 'bundle-host';
              openHost.style.gridRow = `${gridRow} / ${gridRow + 1}`;
              openHost.style.gridColumn = `${gridColStart} / ${gridColStart + 1}`;
              grid.appendChild(openHost);
              openCol = col;
            }

            // Render the event inside the open host
            if (openHost) {
              openHost.appendChild(buildEventEl(ev, /*inBundle=*/true));
            }

            // CLOSE if next is NOT a bundle in the same column
            if (!nextIsSameBundle) {
              openHost = null;
              openCol = null;
            }

            continue; // handled
          }

          // If we get here, it's a normal (non-slice) event:
          // Ensure no host is considered open (next slice will re-open as needed)
          openHost = null; openCol = null;

          // --- normal spanning logic (unchanged) ---
          const start = ev.startIdx;
          const endExclusive = ev.startIdx + ev.durationDays;
          const a = Math.max(Math.min(start, endExclusive), minIdx);
          const b = Math.min(Math.max(start, endExclusive), maxIdx);

          const firstVisible = (() => { for (let d = a; d < b; d++) if (dayColIndex.has(d)) return d; return null; })();
          const lastVisible  = (() => { for (let d = b - 1; d >= a; d--) if (dayColIndex.has(d)) return d; return null; })();
          if (firstVisible == null || lastVisible == null) continue;

          let spanDays = 0, extraSeasonal = 0;
          for (let d = Math.min(start, endExclusive); d < Math.max(start, endExclusive); d++) {
            if (dayColIndex.has(d)) spanDays++;
            if (d !== start) extraSeasonal += (seasonalByDay.get(d)?.length || 0);
          }
          const span = spanDays + extraSeasonal;
          if (span <= 0) continue;

          const colStart = dayColIndex.get(firstVisible);
          const gridColStart = 2 + colStart;
          grid.appendChild(buildEventEl(ev, /*inBundle=*/false, gridColStart, span));
        }

        // row done — make sure state is cleared
        openHost = null;
        openCol = null;
      }

      // ---- meta + tracker ----
      const firstL = (function(){const {year,week,day}=idxToISODay(minIdx); return `${year}-W${String(week).padStart(2,'0')}-${day}`})();
      const lastL  = (function(){const {year,week,day}=idxToISODay(maxIdx-1); return `${year}-W${String(week).padStart(2,'0')}-${day}`})();
      setText('meta', `Timelines: ${timelines.length} • Days: ${totalDays} • Range: ${firstL} → ${lastL}`);
      setupCornerYearTrackerHorizontal(grid, corner);
    }

    /** ===================== BOOT ===================== **/
    (async function main() {
      try {
        await bootstrapState();
        await applyStateToRenderer();

        if (visualDebug && !editMode) enterEditMode();

        const btn = document.getElementById('toggle-editor');
        if (btn) btn.addEventListener('click', () => (editMode ? exitEditMode() : enterEditMode()));

        const btnCollapse = document.getElementById('btn-collapse');
        if (btnCollapse) btnCollapse.onclick = toggleCollapseEmptyDays;

        const btnImport = document.getElementById('btn-import');
        const btnDownload = document.getElementById('btn-download');
        if (btnImport) btnImport.onclick = onImportJSON;
        if (btnDownload) btnDownload.onclick = onDownloadJSON;

        const btnTheme = document.getElementById('btn-theme');
        if (btnTheme) btnTheme.onclick = toggleTheme;
        // Initial label sync (in case applyUIFromSettings hasn’t run yet)
        syncHeaderControlsFromSettings();

      } catch (e) {
        console.error(e);
        setText('err', e.message || String(e));
      }
    })();
  </script>
</body>
</html>
