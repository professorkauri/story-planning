<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Vertical Timelines (events + character/location icons)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles/timelines.css">
</head>

<body>
  <header>
    <h1>Vertical Timelines</h1>
    <div class="meta" id="meta">Loading…</div>
    <div class="err" id="err"></div>
  </header>

  <div class="viewport">
    <div id="grid" class="grid" role="table" aria-label="Timelines grid"></div>
  </div>

  <script>
    /** ===================== CONFIG ===================== **/
    const TIMELINES_DIR = 'timelines/';
    const INDEX_JSON = TIMELINES_DIR + 'index.json';

    const EVENT_IMAGES_DIR = 'images/events/';
    const CHAR_IMAGES_DIR = 'images/characters/';
    const LOC_IMAGES_DIR = 'images/locations/';
    const IMAGE_EXTS = ['png', 'jpg', 'jpeg', 'webp', 'gif', 'svg', 'avif'];

    /** Inline template for CSS testing (used only if no files can be read) */
    const INLINE_TEMPLATE_CSV =
      `
Harry Potter and the Goblet of Fire,,,,,,
Start,Duration,Description,Category,Image,Characters,Location
2025-02,2w,Ordinary World - living a quiet village life,Background,Wand,HarryPotter,UnderStairs
2w,1w,Call to Adventure - mysterious stranger arrives,Call,,,
1w,1w,Refusal of the Call - doubts and fear,Conflict,,,
1w,1w,Meeting the Mentor - wise elder offers guidance,Guidance,,,Hogwarts
2w,3w,Crossing the Threshold - leaves village to unknown lands,Transition,,,
1w,2w,Tests - Allies - Enemies - faces trials and gains companions,Trial,,,
2w,2w,Approach to the Inmost Cave - enters dark forest,Preparation,,,
1w,1w,Ordeal - battles the shadow beast,Climax,,,
1w,2w,Reward - gains the sacred relic,Reward,,,
2w,2w,The Road Back - pursued by enemies,Conflict,,,
1w,1w,Resurrection - final test of character,Climax,,,
1w,2w,Return with the Elixir - brings knowledge to village,Return,,HarryPotter,
  `;

    /** ===================== SMALL HELPERS ===================== **/
    const $ = (id) => document.getElementById(id);
    const setText = (id, txt) => { const el = $(id); if (el) el.textContent = txt; };

    function isSpecificWeek(s) { return /^\d{4}-\d{2}$/.test(s || ''); }
    function parseRelWeeks(s) { const m = /^(\d+)\s*[wW]$/.exec(s || ''); return m ? parseInt(m[1], 10) : null; }
    function stripExt(name) { return name.replace(/\.[^.]+$/, ''); }
    function encSeg(s) { return encodeURIComponent(s).replace(/%2F/g, '/'); }

    /* Robust ISO week helpers */
    function isoWeekToDate(iso) {
      const [yStr, wStr] = iso.split('-'); const Y = +yStr, W = +wStr;
      const jan4 = new Date(Date.UTC(Y, 0, 4)); const d = jan4.getUTCDay() || 7;
      const monW1 = new Date(jan4); monW1.setUTCDate(jan4.getUTCDate() - (d - 1));
      const monW = new Date(monW1); monW.setUTCDate(monW1.getUTCDate() + (W - 1) * 7); monW.setUTCHours(0, 0, 0, 0);
      return monW;
    }
    function isoWeekToIdx(iso) {
      const d = isoWeekToDate(iso); const epochMon = new Date(Date.UTC(1970, 0, 5));
      return Math.floor((d - epochMon) / (7 * 24 * 3600 * 1000));
    }
    function idxToISOWeek(idx) {
      const epochMon = new Date(Date.UTC(1970, 0, 5));
      const d = new Date(epochMon); d.setUTCDate(epochMon.getUTCDate() + idx * 7);
      const t = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
      const day = t.getUTCDay() || 7; t.setUTCDate(t.getUTCDate() + (4 - day));
      const isoYear = t.getUTCFullYear();
      const w1 = new Date(Date.UTC(isoYear, 0, 4)); const wd = w1.getUTCDay() || 7;
      const w1Mon = new Date(w1); w1Mon.setUTCDate(w1.getUTCDate() - (wd - 1));
      const diff = (d - w1Mon); const isoWeek = 1 + Math.floor(diff / (7 * 24 * 3600 * 1000));
      return { year: isoYear, week: isoWeek };
    }

    /** CSV parse (quoted commas handled) */
    function parseCSV(text) {
      const rows = []; let row = [], cur = '', inQ = false;
      for (let i = 0; i < text.length; i++) {
        const ch = text[i], nx = text[i + 1];
        if (ch === '"') { if (inQ && nx === '"') { cur += '"'; i++; } else inQ = !inQ; }
        else if (ch === ',' && !inQ) { row.push(cur); cur = ''; }
        else if ((ch === '\n' || ch === '\r') && !inQ) {
          if (ch === '\r' && nx === '\n') i++;
          row.push(cur); cur = ''; rows.push(row); row = [];
        } else cur += ch;
      }
      row.push(cur); rows.push(row);
      const maxLen = Math.max(...rows.map(r => r.length));
      return rows.map(r => r.concat(Array(Math.max(0, maxLen - r.length)).fill('')));
    }

    /** Make an <img> that tries extensions in order; hides itself if none exist. Works with file:// */
    function makeSmartImg(dir, name, className, alt) {
      if (!name) return null;
      const img = document.createElement('img');
      img.className = className || '';
      img.alt = alt || name;
      img.loading = 'lazy';
      const exts = IMAGE_EXTS.slice();
      let i = 0;
      const tryNext = () => {
        if (i >= exts.length) { img.remove(); return; }
        img.src = `${dir}${encSeg(name)}.${exts[i++]}`;
      };
      img.onerror = tryNext;
      tryNext();
      return img;
    }

    /** ===================== DISCOVERY ===================== **/
    async function discoverFiles() {
      try {
        const r = await fetch(INDEX_JSON, { cache: 'no-store' });
        if (!r.ok) return [];
        const arr = await r.json();
        if (!Array.isArray(arr)) return [];
        const files = [];
        for (const entry of arr) {
          if (typeof entry !== 'string') continue;
          const s = entry.trim();
          if (!s || !/\.csv$/i.test(s)) continue;
          if (!files.includes(s)) files.push(s);
        }
        return files;
      } catch {
        return [];
      }
    }

    /** CSV -> timeline (title row + events, with row-level validation) */
    function csvToTimeline(filename, csvText) {
      const rowsRaw = parseCSV(csvText).filter(r => r.some(c => (c || '').trim() !== ''));
      if (!rowsRaw.length) throw new Error('CSV is empty');
      const titleRow = rowsRaw[0];
      const title = (titleRow.find(c => (c || '').trim() !== '') || '').trim() || stripExt(filename);
      const rows = rowsRaw.slice(1);

      const events = [];
      for (const row of rows) {
        const [d, dur, desc, cat, img, chars, locs] = [
          (row[0] || '').trim(), (row[1] || '').trim(),
          (row[2] || '').trim(), (row[3] || '').trim(),
          (row[4] || '').trim(), (row[5] || '').trim(),
          (row[6] || '').trim()
        ];
        if (!d && !dur && !desc && !cat && !img && !chars && !locs) continue;
        const durationWeeks = parseRelWeeks(dur);
        if (!durationWeeks) continue;
        if (!isSpecificWeek(d) && parseRelWeeks(d) == null) continue;

        const characters = (chars ? chars.split(/\s+/).filter(Boolean) : []);
        const locations = (locs ? locs.split(/\s+/).filter(Boolean) : []);
        events.push({ rawDate: d, durationWeeks, desc, category: cat, imageName: img || '', characters, locations });
      }
      if (!events.length) throw new Error('No valid events found');
      return { title, events };
    }

    /** Resolve relative dates */
    function resolveTimelineWeeks(tl) {
      let prevEnd = null;
      const events = tl.events.map(ev => {
        let startIdx;
        if (isSpecificWeek(ev.rawDate)) startIdx = isoWeekToIdx(ev.rawDate);
        else { const rel = parseRelWeeks(ev.rawDate) || 0; startIdx = (prevEnd == null) ? rel : (prevEnd + rel); }
        const durationWeeks = Math.max(1, ev.durationWeeks | 0);
        const endIdx = startIdx + durationWeeks;
        prevEnd = endIdx;
        return { ...ev, startIdx, durationWeeks };
      });
      return { title: tl.title, events };
    }

    /** ===================== RENDER ===================== **/
    async function renderGridVertical(timelines) {
      const grid = $('grid'); grid.innerHTML = '';

      // Global range
      const bounds = timelines.flatMap(tl => tl.events.map(ev => [ev.startIdx, ev.startIdx + ev.durationWeeks]));
      const minIdx = Math.min(...bounds.map(b => b[0]));
      const maxIdx = Math.max(...bounds.map(b => b[1]));
      const totalWeeks = Math.max(1, maxIdx - minIdx);

      const weekIdxs = []; for (let i = maxIdx - 1; i >= minIdx; i--) weekIdxs.push(i);
      const weekLabels = weekIdxs.map(idx => {
        const { year, week } = idxToISOWeek(idx);
        return `${year}-${String(week).padStart(2, '0')}`;
      });

      // Build a map of active weeks -> number of overlapping events in that week
      const activeWeekCounts = new Map();

      for (const tl of timelines) {
        for (const ev of tl.events) {
          const start = ev.startIdx;
          const end = ev.startIdx + ev.durationWeeks; // exclusive
          for (let idx = start; idx < end; idx++) {
            activeWeekCounts.set(idx, (activeWeekCounts.get(idx) || 0) + 1);
          }
        }
      }

      // Grid template
      grid.style.gridTemplateColumns = `[weeks] 120px ${timelines.map(() => `minmax(var(--timeline-col-min), var(--timeline-col-max))`).join(' ')}`;
      grid.style.gridTemplateRows = weekIdxs.map(() => `minmax(var(--week-row-min), auto)`).join(' ');

      // Corner
      const corner = document.createElement('div');
      corner.className = 'corner';
      corner.style.gridColumn = '1 / 2';
      corner.style.gridRow = '1 / 2';
      corner.textContent = 'Week';
      grid.appendChild(corner);

      // Headers
      timelines.forEach((tl, cIdx) => {
        const th = document.createElement('div');
        th.className = 'thead';
        th.textContent = tl.title;
        th.style.gridColumn = `${2 + cIdx} / ${3 + cIdx}`;
        th.style.gridRow = '1 / 2';
        grid.appendChild(th);
      });

      // Week labels + background cells
      weekLabels.forEach((label, rIdx) => {
        const weekIdx = weekIdxs[rIdx]; // actual ISO-week index for this row

        const wl = document.createElement('div');
        wl.className = 'wlabel';

        // Inner container holds the content + state
        const inner = document.createElement('div');
        inner.className = 'wlabel__inner';
        inner.textContent = label;

        // add class + optional data-count on the INNER element
        const count = activeWeekCounts.get(weekIdx) || 0;
        if (count > 0) {
          inner.classList.add('has-events');
          inner.dataset.count = String(count);
        }

        wl.appendChild(inner);

        wl.style.gridColumn = '1 / 2';
        wl.style.gridRow = `${2 + rIdx} / ${3 + rIdx}`;
        grid.appendChild(wl);

        timelines.forEach((_, cIdx) => {
          const bg = document.createElement('div');
          bg.className = 'cell';
          bg.style.gridColumn = `${2 + cIdx} / ${3 + cIdx}`;
          bg.style.gridRow = `${2 + rIdx} / ${3 + rIdx}`;
          grid.appendChild(bg);
        });
      });


      // Events
      const rowOfIdx = (idx) => weekIdxs.indexOf(idx);
      for (let cIdx = 0; cIdx < timelines.length; cIdx++) {
        const tl = timelines[cIdx];
        for (const ev of tl.events) {
          const start = ev.startIdx, end = ev.startIdx + ev.durationWeeks;
          const vStart = Math.min(Math.max(start, minIdx), maxIdx - 1);
          const vEnd = Math.min(Math.max(end - 1, minIdx), maxIdx - 1);
          const vStartRow = rowOfIdx(vStart), vEndRow = rowOfIdx(vEnd);
          if (vStartRow === -1 || vEndRow === -1) continue;

          const el = document.createElement('div');
          el.className = 'event';
          el.dataset.category = ev.category || '';

          el.style.gridColumn = `${2 + cIdx} / ${3 + cIdx}`;
          el.style.gridRow = `${2 + Math.min(vStartRow, vEndRow)} / ${2 + Math.max(vStartRow, vEndRow) + 1}`;

          const { year, week } = idxToISOWeek(start);
          const labelStart = `${year}-${String(week).padStart(2, '0')}`;

          const topline = document.createElement('div');
          topline.className = 'topline';

          // media stays at the very top of the card
          let media = null;
          if (ev.imageName) {
            media = makeSmartImg(EVENT_IMAGES_DIR, ev.imageName, 'thumb', ev.imageName);
          }
          if (!media) {
            const ph = document.createElement('div');
            ph.className = 'thumb';
            media = ph;
          }
          el.prepend(media);

          // 1) Category (only if provided)
          if (ev.category) {
            const cat = document.createElement('div');
            cat.className = 'cat';
            cat.textContent = ev.category;
            topline.appendChild(cat);
          }

          // 2) Title
          const title = document.createElement('div');
          title.className = 'desc';
          title.textContent = ev.desc || '(no description)';
          topline.appendChild(title);

          // 3) Date & duration (category removed from here)
          const meta = document.createElement('div');
          meta.className = 'meta';
          meta.textContent = `${labelStart} • ${ev.durationWeeks}w`;
          topline.appendChild(meta);

          // attach topline to the event card
          el.appendChild(topline);

          const chips = document.createElement('div');
          chips.className = 'chips';

          // Characters
          for (const n of ev.characters || []) {
            const a = document.createElement('a');
            a.className = 'chip';
            a.href = `characters/${encodeURIComponent(n)}.html`;
            a.title = `Character: ${n}`;

            const icon = makeSmartImg(CHAR_IMAGES_DIR, n, 'icon', n);
            if (icon) a.appendChild(icon);

            const label = document.createElement('span');
            label.textContent = n;
            a.appendChild(label);

            chips.appendChild(a);
          }

          // Locations
          for (const n of ev.locations || []) {
            const a = document.createElement('a');
            a.className = 'chip';
            a.href = `locations/${encodeURIComponent(n)}.html`;
            a.title = `Location: ${n}`;

            const icon = makeSmartImg(LOC_IMAGES_DIR, n, 'icon', n);
            if (icon) a.appendChild(icon);

            const label = document.createElement('span');
            label.textContent = n;
            a.appendChild(label);

            chips.appendChild(a);
          }
          if (chips.children.length) el.appendChild(chips);
          if ((ev.durationWeeks | 0) <= 1) el.classList.add('small');

          grid.appendChild(el);
        }
      }

      // Meta line
      const firstLabel = (function () { const { year, week } = idxToISOWeek(minIdx); return `${year}-${String(week).padStart(2, '0')}`; })();
      const lastLabel = (function () { const { year, week } = idxToISOWeek(maxIdx - 1); return `${year}-${String(week).padStart(2, '0')}`; })();
      setText('meta', `Timelines: ${timelines.length} • Weeks: ${totalWeeks} • Range: ${firstLabel} → ${lastLabel}`);
    }

    /** ===================== BOOT ===================== **/
    (async function main() {
      try {
        let files = await discoverFiles();  // lenient

        const timelines = [];

        // Load each CSV listed in index.json, skipping failures
        for (const fname of files) {
          try {
            const text = await fetch(TIMELINES_DIR + fname, { cache: 'no-store' }).then(r => {
              if (!r.ok) throw new Error(`HTTP ${r.status}`);
              return r.text();
            });
            timelines.push(csvToTimeline(fname, text));
          } catch (e) {
            console.warn(`Skip ${fname}:`, e.message || e);
          }
        }

        // If none loaded, try template_test.csv in /timelines
        if (!timelines.length) {
          try {
            const text = await fetch(TIMELINES_DIR + 'template_test.csv', { cache: 'no-store' }).then(r => {
              if (!r.ok) throw new Error(`HTTP ${r.status}`);
              return r.text();
            });
            timelines.push(csvToTimeline('template_test.csv', text));
            setText('err', 'Using timelines/template_test.csv (fallback).');
          } catch {
            // Final fallback: inline template (works under file://)
            try {
              timelines.push(csvToTimeline('template_test.csv', INLINE_TEMPLATE_CSV));
              setText('err', 'Using inline template (file access unavailable).');
            } catch (e2) {
              throw new Error('No CSV timelines found. Add files to /timelines or create timelines/index.json.');
            }
          }
        }

        // Resolve + render
        const resolved = timelines.map(resolveTimelineWeeks);
        await renderGridVertical(resolved);

      } catch (e) {
        console.error(e);
        setText('err', e.message || String(e));
      }
    })();
  </script>

</body>

</html>