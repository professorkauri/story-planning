<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Pokemon Timelines</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Reuse your existing styles; this file only provides structure. -->
  <link rel="stylesheet" href="styles.css" />
</head>

<body data-theme="light">
  <header class="app-header">
    <div class="left">
      <h1 class="app-title">Pokemon Timelines</h1>
    </div>
    <div class="right controls">
      <button id="btn-theme" class="btn">Toggle Theme</button>
      <button id="btn-edit" class="btn primary">Edit</button>
      <!-- Import/Download moved into the editor header -->
    </div>
  </header>

  <main class="app-main">
    <!-- Editor (hidden by default) -->
    <aside id="editor" class="panel editor hidden" aria-hidden="true">
      <div class="editor-header">
        <h2>Editor</h2>
        <div class="row gap">
          <label class="btn">
            Import .js
            <input id="file-import-editor" type="file" accept=".js" hidden />
          </label>
          <button id="btn-download-editor" class="btn">Download .js</button>
          <button id="btn-exit-edit" class="btn">Done</button>
        </div>
      </div>

      <div class="editor-body">
        <section>
          <div class="timeline-editor-head">
            <h3>Timelines</h3>
            <div class="row gap">
              <button id="btn-add-timeline" class="btn">+ Add Timeline</button>
              <button id="btn-dup-timeline" class="btn">Duplicate</button>
            </div>
          </div>
          <div id="timeline-list" class="listbox" role="listbox" aria-label="Timelines"></div>
        </section>

        <section id="timeline-editor" class="stack gap">
          <div class="timeline-editor-head">
            <h3>Timeline Details</h3>
            <div class="row gap">
              <button id="btn-add-event" class="btn">+ Add Event</button>
              <button id="btn-del-timeline" class="btn danger">Delete Timeline</button>
            </div>
          </div>
          <div class="timeline-editor-body">

            <div class="column between">
              <div>
              <label>Title
                <input id="tl-title" type="text" placeholder="Timeline title" />
              </label>
              
              <label>Anchor Year
                <input id="tl-year" type="text" step="1" placeholder="2000 | 5aKANTO" />
              </label>
              
              <label>Color (optional)
                <input id="tl-color" type="color" />
              </label>
            </div>
            <div>
              <label style="flex:1 1 100%;">Timeline Description
                <textarea id="tl-desc" rows="3" placeholder="Shown on the anchor event (Markdown supported)"></textarea>
              </label>
              
              <label style="flex:1 1 100%;">Timeline Image (slug/subpath/url)
                <input id="tl-image" type="text" placeholder="slug.webp | folder/slug.webp | https://…" />
              </label>
            </div>

              <button id="btn-sort-events" class="btn">Sort</button>
            </div>

            <table class="events-table">
              <thead>
                <tr>
                  <th style="width:10rem">Year</th>
                  <th style="width:16rem">Title</th>
                  <th>Description</th>
                  <th style="width:18rem">Image (slug/subpath/url)</th>
                  <th style="width:5rem"></th>
                </tr>
              </thead>
              <tbody id="events-body"></tbody>
            </table>
            <div class="muted small">Year accepts <code>####</code> or <code>####bc</code> (e.g., <code>1994</code>,
              <code>3000000bc</code>).
            </div>
          </div>
        </section>
      </div>
    </aside>

    <!-- Timeline Grid -->
    <section class="viewport">
      <div id="grid" class="year-grid" role="grid" aria-label="Year timelines grid"></div>
    </section>
  </main>

  <!-- Your data file as a classic script (global) -->
  <script src="./timelines.js"></script>

  <!-- Main logic -->
  <script type="module">
    const DATA_DEFAULT = window.TIMELINES_DEFAULT;

    /***************
     * Data Model  *
     ***************/
    /**
     * Data shape:
     * window.TIMELINES_DEFAULT = {
     *   timelines: [
     *     { id, title, color?, events: [{year:"1994"| "3000000bc", title?, desc?, image?, category?}] }
     *   ]
     * }
     */
    const state = {
      timelines: [],
      editMode: false,
      selectedTimelineId: null,
      theme: 'light',
      hiddenTimelineIds: new Set(),
      showDescriptions: false,
      showImages: true,
    };

    function moveTimeline(fromIndex, toIndex) {
      if (fromIndex === toIndex) return;
      if (fromIndex < 0 || toIndex < 0) return;
      if (fromIndex >= state.timelines.length || toIndex >= state.timelines.length) return;

      const [item] = state.timelines.splice(fromIndex, 1);
      state.timelines.splice(toIndex, 0, item);
    }

    function indexOfTimelineId(id) {
      return state.timelines.findIndex(t => t.id === id);
    }

    function normalizeTimelineKey(name) {
      return String(name || '').trim().toLowerCase();
    }

    function getTimelineByName(name, timelines) {
      const key = normalizeTimelineKey(name);
      return (timelines || []).find(t => normalizeTimelineKey(t.title) === key) || null;
    }

    /**
     * Resolve a timeline's anchor year to an absolute numeric year.
     * Supports:
     *  - 1999
     *  - "1999"
     *  - "5aKANTO" (relative to another timeline anchor)
     */
    function resolveTimelineAnchorYear(tl, ctx) {
      const timelines = ctx?.timelines || (typeof state !== 'undefined' ? state.timelines : []) || [];
      const cache = ctx?.cache || null;
      const stack = ctx?.stack || [];

      if (!tl) return 2000;

      if (cache && cache.has(tl.id)) return cache.get(tl.id);

      // Cycle protection
      if (stack.includes(tl.id)) {
        throw new Error(`Circular anchor reference detected: ${stack.join(' -> ')} -> ${tl.id}`);
      }
      stack.push(tl.id);

      const raw = tl.year;

      let out;
      if (typeof raw === 'number' && Number.isFinite(raw)) {
        out = raw;
      } else if (typeof raw === 'string' && raw.trim() !== '') {
        // Note: baseYear is irrelevant for absolute years,
        // but parseYearToken also handles "ya" if someone ever uses it in anchor years.
        out = parseYearToken(raw, 2000, { timelines, cache, stack }).year;
      } else {
        out = 2000;
      }

      stack.pop();
      if (cache) cache.set(tl.id, out);
      return out;
    }



    /**********************
     * Utility / Parsing  *
     **********************/
    // Add this helper (or replace your existing one if present)
    function formatWithCommas(x) {
      // Inserts commas every 3 digits, e.g. 1234567 -> 1,234,567
      return String(x).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }

    // Replace your current formatYearSigned with this version
    function formatYearSigned(y) {
      const abs = Math.abs(y);
      const numStr = abs >= 10000 ? formatWithCommas(abs) : String(abs);
      return y < 0 ? `${numStr}bc` : numStr;
    }

    // Wrap parenthetical parts of a title in <span>(...)</span> safely.
    function formatTitleWithParens(title) {
      if (!title) return '';
      const safe = escapeHtml(String(title));
      // Turn (...) → <span>(...)</span> (supports multiple sets)
      return safe.replace(/\(([^)]+)\)/g, (_m, inner) => `<span>(${inner})</span>`);
    }

    function getAnchorEvent(tl) {
      if (!tl) return null;

      // We store tl.year as a token string now ("2000" or "5aKANTO")
      // The grid uses resolveTimelineAnchorYear() to place it.
      return {
        year: String(tl.year || '2000'),   // token, not forced numeric
        title: tl.title || '(Untitled)',
        desc: tl.description || '',
        image: tl.image || '',
        __isAnchor: true,
      };
    }


    // Replace your current parseYearToken with this version
    function parseYearToken(str, baseYear = 2000, ctx = null) {
      if (typeof str !== 'string') throw new Error('Year must be a string');
      const s = str.trim();

      const timelines =
        ctx?.timelines ||
        (typeof state !== 'undefined' ? state.timelines : []) ||
        [];

      // 1) Plain numeric / BC / YA: 1999 | 300bc | 20ya
      {
        const m = s.toLowerCase().match(/^(\d+)(bc|ya)?$/);
        if (m) {
          const n = parseInt(m[1], 10);
          if (Number.isNaN(n)) throw new Error('Invalid year number: ' + str);

          const suffix = m[2] || '';
          const anchor = Number.isFinite(+baseYear) ? +baseYear : 2000;

          let year;
          if (suffix === 'bc') year = -n;
          else if (suffix === 'ya') year = anchor - n;
          else year = n;

          return { year, isBC: year < 0 };
        }
      }

      // 2) "After another anchor": 5aKANTO  (years after timeline "Kanto" anchor year)
      // Allow letters/numbers/spaces/hyphens/underscores in name (everything after the 'a').
      {
        const m = s.match(/^(\d+)\s*a\s*(.+)$/i);
        if (m) {
          const offset = parseInt(m[1], 10);
          const name = m[2].trim();
          if (!name) throw new Error('Invalid anchor reference (missing name): ' + str);

          const ref = getTimelineByName(name, timelines);
          if (!ref) throw new Error(`Unknown anchor timeline "${name}" in token: ${str}`);

          // Resolve referenced timeline anchor year (supports chaining)
          const localCtx = ctx || { timelines, cache: new Map(), stack: [] };
          const refAnchorYear = resolveTimelineAnchorYear(ref, localCtx);

          const year = refAnchorYear + offset;
          return { year, isBC: year < 0 };
        }
      }

      throw new Error('Invalid year token: ' + str);
    }


    const sortEventsByYear = (a, b) => {
      const ay = parseYearToken(a.year).year;
      const by = parseYearToken(b.year).year;
      return ay - by;
    };

    function collectAllYears(timelines) {
      const set = new Set();
      const ctx = { timelines, cache: new Map(), stack: [] };

      for (const tl of timelines) {
        const anchorYear = resolveTimelineAnchorYear(tl, ctx);

        // include anchor year
        set.add(anchorYear);

        // include events (ya is relative to *this* timeline's resolved anchor year)
        for (const ev of tl.events || []) {
          set.add(parseYearToken(ev.year, anchorYear, ctx).year);
        }
      }

      return Array.from(set).sort((a, b) => a - b);
    }


    function resolveImageSrc(input) {
      if (!input) return '';
      const s = String(input).trim();
      if (/^https?:\/\//i.test(s)) return s;     // absolute URL
      if (s.startsWith('/')) return s;           // absolute site path
      return `images/${s}`;                      // slug/subpath → images/<path>
    }

    let descTooltipEl = null;

    function ensureDescTooltip() {
      if (descTooltipEl) return descTooltipEl;

      const el = document.createElement('div');
      el.id = 'desc-tooltip';
      el.style.position = 'fixed';
      el.style.zIndex = '9999';
      el.style.pointerEvents = 'none';
      el.style.display = 'none';

      document.body.appendChild(el);
      descTooltipEl = el;

      // Hide tooltip on scroll / click / escape
      window.addEventListener('scroll', hideDescTooltip, true);
      window.addEventListener('pointerdown', hideDescTooltip, true);
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape') hideDescTooltip(); });

      return el;
    }

    function showDescTooltip(html, clientX, clientY) {
      const el = ensureDescTooltip();
      el.innerHTML = html;

      // show first so we can measure
      el.style.display = 'block';

      const pad = 12;
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const rect = el.getBoundingClientRect();

      let x = clientX + pad;
      let y = clientY + pad;

      if (x + rect.width + pad > vw) x = Math.max(pad, vw - rect.width - pad);
      if (y + rect.height + pad > vh) y = Math.max(pad, vh - rect.height - pad);

      el.style.left = `${x}px`;
      el.style.top = `${y}px`;
    }

    function hideDescTooltip() {
      if (!descTooltipEl) return;
      descTooltipEl.style.display = 'none';
    }


    /** Simple, safe-ish markdown → HTML for chips.
 * Supports: links [text](https://...), **bold**, *italic*, `code`, and line breaks.
 * Intentionally conservative to avoid XSS and layout surprises.
 */
    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }
    function markdownToHtml(md) {
      if (!md) return '';
      let s = escapeHtml(String(md).replace(/\r\n/g, '\n'));

      // Inline code first to protect contents
      s = s.replace(/`([^`]+)`/g, (_m, code) => `<code>${code}</code>`);

      // Links: [label](https://example.com) — only allow http/https
      s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g, (_m, label, url) => {
        const safeLabel = escapeHtml(label);
        const safeUrl = escapeHtml(url);
        return `<a href="${safeUrl}" target="_blank" rel="noopener">${safeLabel}</a>`;
      });

      // Bold, then italics (simple, non-greedy)
      s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      s = s.replace(/\*([^*]+)\*/g, '<em>$1</em>');

      // Line breaks
      s = s.replace(/\n/g, '<br>');

      return s;
    }


    /*****************
     * Theme toggle  *
     *****************/
    function applyTheme() {
      document.body.setAttribute('data-theme', state.theme);
    }
    function toggleTheme() {
      state.theme = state.theme === 'light' ? 'dark' : 'light';
      applyTheme();
    }

    /**********************
     * Rendering (Grid)   *
     **********************/

    function makeConfirmable(btn, onConfirm, {
      idleText = btn.textContent || 'Delete',
      confirmText = 'Confirm',
      timeoutMs = 3000
    } = {}) {
      let timer = null;

      const reset = () => {
        btn.textContent = idleText;
        btn.classList.remove('confirm');
        btn.dataset.confirm = '';
        if (timer) { clearTimeout(timer); timer = null; }
      };

      btn.onclick = (e) => {
        if (btn.dataset.confirm === 'true') {
          reset();
          onConfirm(e);
          return;
        }
        btn.dataset.confirm = 'true';
        btn.textContent = confirmText;
        btn.classList.add('confirm');
        timer = setTimeout(reset, timeoutMs);
      };

      // Optional niceties
      btn.addEventListener('mouseleave', reset);
      btn.addEventListener('blur', reset);

      return reset;
    }


  function renderTimelineList() {
    const list = document.getElementById('timeline-list');
    list.innerHTML = '';

    // Track current drag state locally
    let dragId = null;

    const clearDragClasses = () => {
      list.querySelectorAll('.option').forEach(el => {
        el.classList.remove('dragging', 'drag-over');
      });
    };

    const onDropReorder = (dropId) => {
      if (!dragId || dragId === dropId) return;

      const from = indexOfTimelineId(dragId);
      const to = indexOfTimelineId(dropId);
      if (from < 0 || to < 0) return;

      moveTimeline(from, to);

      // Re-render everything that depends on order
      renderTimelineList();
      renderToggleBar();
      renderYearGrid();

      // Keep selection stable
      if (state.selectedTimelineId) {
        const selectedEl = list.querySelector(`.option[data-id="${state.selectedTimelineId}"]`);
        if (selectedEl) selectedEl.setAttribute('aria-selected', 'true');
      }
    };

    // Build options
    for (const tl of state.timelines) {
      const isSelected = tl.id === state.selectedTimelineId;

      const opt = document.createElement('div');
      opt.className = 'option';
      opt.setAttribute('role', 'option');
      opt.setAttribute('data-id', tl.id);
      opt.setAttribute('aria-selected', isSelected ? 'true' : 'false');
      opt.setAttribute('tabindex', isSelected ? '0' : '-1');
      opt.setAttribute('data-state', 'default');
      opt.style.setProperty('--tlCol', tl.color || '#8aa');
      opt.textContent = tl.title || '(Untitled)';

      // Click + keyboard behaviour (your existing behaviour)
      opt.addEventListener('click', () => selectTimeline(tl.id));
      opt.addEventListener('keydown', (e) => handleListboxKey(e, opt));

      // --- Drag & Drop reordering ---
      opt.draggable = true;

      opt.addEventListener('dragstart', (e) => {
        dragId = tl.id;
        opt.classList.add('dragging');

        // Some browsers need data set for DnD to work
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', tl.id);
      });

      opt.addEventListener('dragend', () => {
        dragId = null;
        clearDragClasses();
      });

      opt.addEventListener('dragenter', (e) => {
        e.preventDefault();
        if (!dragId || dragId === tl.id) return;
        opt.classList.add('drag-over');
      });

      opt.addEventListener('dragleave', () => {
        opt.classList.remove('drag-over');
      });

      opt.addEventListener('dragover', (e) => {
        // Must prevent default to allow drop
        e.preventDefault();
        if (!dragId || dragId === tl.id) return;
        e.dataTransfer.dropEffect = 'move';
      });

      opt.addEventListener('drop', (e) => {
        e.preventDefault();

        // Prefer the stored dragId, but also read transfer data (safety)
        const droppedOnId = tl.id;
        const fromId = dragId || e.dataTransfer.getData('text/plain');

        dragId = fromId;
        onDropReorder(droppedOnId);
        clearDragClasses();
      });

      list.appendChild(opt);
    }

    // Ensure at least one is tabbable for keyboard users
    const focusable = list.querySelector('[tabindex="0"]') || list.querySelector('.option');
    if (focusable && document.activeElement.closest('#timeline-list')) {
      focusable.focus();
    }
  }


    function selectTimeline(id) {
      state.selectedTimelineId = id;
      renderTimelineList();
      renderTimelineEditor();   // refresh details table
    }

    function handleListboxKey(e, currentOpt) {
      const list = document.getElementById('timeline-list');
      const opts = Array.from(list.querySelectorAll('.option'));
      const idx = opts.indexOf(currentOpt);

      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        currentOpt.click();
        return;
      }

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        const next = opts[Math.min(idx + 1, opts.length - 1)];
        if (next) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          next.setAttribute('tabindex', '0');
          next.focus();
        }
        return;
      }

      if (e.key === 'ArrowUp') {
        e.preventDefault();
        const prev = opts[Math.max(idx - 1, 0)];
        if (prev) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          prev.setAttribute('tabindex', '0');
          prev.focus();
        }
        return;
      }

      // Optional: Home/End keys
      if (e.key === 'Home') {
        e.preventDefault();
        const first = opts[0];
        if (first) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          first.setAttribute('tabindex', '0');
          first.focus();
        }
      }
      if (e.key === 'End') {
        e.preventDefault();
        const last = opts[opts.length - 1];
        if (last) {
          opts.forEach(o => o.setAttribute('tabindex', '-1'));
          last.setAttribute('tabindex', '0');
          last.focus();
        }
      }
    }


    function renderToggleBar() {
      // Ensure we have a container just before the grid
      const viewport = document.querySelector('.viewport');
      const gridEl = document.getElementById('grid');

      let container = viewport.querySelector('.toggles-container');
      if (!container) {
        container = document.createElement('div');
        container.className = 'toggles-container';
        viewport.insertBefore(container, gridEl);
      }
      container.innerHTML = '';

      // --- Timeline toggles (existing behaviour) ---
      let tlBar = container.querySelector('.timeline-toggles');
      if (!tlBar) {
        tlBar = document.createElement('div');
        tlBar.className = 'timeline-toggles';
        container.appendChild(tlBar);
      }
      tlBar.innerHTML = '';

      if (!state.timelines.length) {
        tlBar.innerHTML = '<span class="muted small">No timelines yet.</span>';
      } else {
        for (const tl of state.timelines) {
          const id = `tgl_${tl.id}`;
          const wrap = document.createElement('label');
          wrap.className = 'toggle';
          wrap.style.setProperty('--tlCol', tl.color || '#8aa');

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.id = id;
          cb.checked = !state.hiddenTimelineIds.has(tl.id);
          cb.onchange = () => {
            if (cb.checked) state.hiddenTimelineIds.delete(tl.id);
            else state.hiddenTimelineIds.add(tl.id);
            renderYearGrid();
          };

          const txt = document.createElement('span');
          txt.className = 'label';
          txt.textContent = tl.title || '(Untitled)';

          wrap.appendChild(cb);
          wrap.appendChild(txt);
          tlBar.appendChild(wrap);
        }
      }

      // --- Content toggles (NEW) ---
      let contentBar = container.querySelector('.content-toggles');
      if (!contentBar) {
        contentBar = document.createElement('div');
        contentBar.className = 'content-toggles';
        container.appendChild(contentBar);
      }
      contentBar.innerHTML = '';

      // helper to build a switch
      const mkSwitch = (labelText, checked, onChange) => {
        const lbl = document.createElement('label');
        lbl.className = 'toggle content-toggle';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = checked;
        cb.onchange = () => { onChange(cb.checked); };

        const text = document.createElement('span');
        text.className = 'label';
        text.textContent = labelText;

        lbl.appendChild(cb);
        lbl.appendChild(text);
        return lbl;
      };

      // Descriptions
      contentBar.appendChild(
        mkSwitch('Descriptions', state.showDescriptions, (v) => {
          state.showDescriptions = v;
          renderYearGrid();
        })
      );

      // Images
      contentBar.appendChild(
        mkSwitch('Images', state.showImages, (v) => {
          state.showImages = v;
          renderYearGrid();
        })
      );
    }

    function renderApp() {
      applyTheme();
      renderHeader();
      renderToggleBar();
      renderYearGrid();
      renderEditorUI();
    }

    function renderHeader() {
      document.getElementById('btn-theme').onclick = toggleTheme;
      document.getElementById('btn-edit').onclick = () => enterEditMode();
      // Import/Download now live in the editor header
    }

    function renderYearGrid() {
      const grid = document.getElementById('grid');
      grid.innerHTML = '';

      // filter visible timelines
      const visibleTimelines = state.timelines.filter(t => !state.hiddenTimelineIds.has(t.id));

      if (!visibleTimelines.length) {
        grid.innerHTML = '<div class="muted">No timelines selected. Toggle one above to show it.</div>';
        return;
      }

      // collect years from VISIBLE ones only
      const years = collectAllYears(visibleTimelines);
      const { columns, colCount } = buildYearColumns(years);

      grid.style.gridTemplateColumns = `var(--label-col-w) repeat(${colCount - 1}, var(--year-col-w))`;

      // header...
      const labelHeader = document.createElement('div');
      labelHeader.className = 'cell header label-header';
      labelHeader.textContent = '';
      grid.appendChild(labelHeader);

      for (let i = 1; i < columns.length; i++) {
        const col = columns[i];
        const cell = document.createElement('div');
        if (col.type === 'year') {
          cell.className = 'cell header year-header';
          cell.textContent = formatYearSigned(col.year);
        } else {
          cell.className = 'cell header gap-header';
          cell.textContent = '…';
        }
        grid.appendChild(cell);
      }

      // body rows ONLY for visible timelines
      for (const tl of visibleTimelines) {
        renderTimelineRow(grid, tl, columns);
      }
    }


    function buildYearColumns(years) {
      const columns = [{ type: 'label' }];
      if (years.length === 0) return { columns, colCount: 1 };
      for (let i = 0; i < years.length; i++) {
        const y = years[i];
        columns.push({ type: 'year', year: y });
        if (i < years.length - 1) {
          const next = years[i + 1];
          if (next - y > 1) columns.push({ type: 'gap' });
        }
      }
      return { columns, colCount: columns.length };
    }

    function renderTimelineRow(grid, timeline, columns) {
      const tlCol = timeline.color || '#8aa';
      const ctx = { timelines: state.timelines, cache: new Map(), stack: [] };
      const anchorYear = resolveTimelineAnchorYear(timeline, ctx);

      // Map: year -> events[]
      const byYear = new Map();

      // 1) Add the anchor event
      const anchorEv = getAnchorEvent(timeline);
      if (anchorEv) {
        const y = parseYearToken(anchorEv.year, anchorYear, ctx).year; // (year is absolute anyway)
        if (!byYear.has(y)) byYear.set(y, []);
        byYear.get(y).push(anchorEv);
      }

      // 2) Add the timeline’s normal events, resolving "ya" against anchorYear
      for (const ev of (timeline.events || []).slice().sort((a, b) => {
        const ay = parseYearToken(a.year, anchorYear, ctx).year;
        const by = parseYearToken(b.year, anchorYear,ctx).year;
        return ay - by;
      })) {
        const y = parseYearToken(ev.year, anchorYear, ctx).year;
        if (!byYear.has(y)) byYear.set(y, []);
        byYear.get(y).push(ev);
      }

      // Label cell
      const label = document.createElement('div');
      label.className = 'cell label-cell';
      const labelinner = document.createElement('div');
      labelinner.className = 'label-inner';
      labelinner.textContent = timeline.title || '(Untitled)';
      label.appendChild(labelinner);
      label.style.setProperty('--tlCol', tlCol);
      grid.appendChild(label);

      // One cell for EACH remaining column in the plan
      for (let i = 1; i < columns.length; i++) {
        const col = columns[i];

        if (col.type === 'gap') {
          const cell = document.createElement('div');
          cell.className = 'cell gap-body';
          cell.style.setProperty('--tlCol', tlCol);
          const marker = document.createElement('div');
          marker.className = 'event collapse';
          marker.textContent = '~';
          cell.appendChild(marker);
          grid.appendChild(cell);
          continue;
        }

        const y = col.year;
        const cell = document.createElement('div');
        cell.className = 'cell year-body';
        cell.style.setProperty('--tlCol', tlCol);

        const eventsHere = byYear.get(y) || [];
        for (const ev of eventsHere) {
          cell.appendChild(renderEventChip(ev));
        }

        grid.appendChild(cell);
      }
    }


    function renderEventChip(ev) {
      const chip = document.createElement('div');
      chip.className = 'event chip';

      // determine visibility flags up front
      const hasImg = !!ev.image && state.showImages;
      const hasDesc = !!(ev.desc && String(ev.desc).trim()) && state.showDescriptions;

      const hasHiddenDesc = !!(ev.desc && String(ev.desc).trim()) && !state.showDescriptions;

      if (hasHiddenDesc) {
        chip.addEventListener('pointerenter', (e) => {
          showDescTooltip(`<div class="chip-desc">${markdownToHtml(ev.desc)}</div>`, e.clientX, e.clientY);
        });
        chip.addEventListener('pointermove', (e) => {
          // keep it tracking the pointer
          showDescTooltip(`<div class="chip-desc">${markdownToHtml(ev.desc)}</div>`, e.clientX, e.clientY);
        });
        chip.addEventListener('pointerleave', hideDescTooltip);
      }


      // set modifier classes for styling
      chip.classList.toggle('no-img', !hasImg);
      chip.classList.toggle('no-desc', !hasDesc);

      // Image
      if (hasImg) {
        const img = document.createElement('img');
        img.loading = 'lazy';
        img.decoding = 'async';
        img.alt = ev.title ? String(ev.title) : 'event image';
        img.src = resolveImageSrc(ev.image);
        img.className = 'chip-img';
        chip.appendChild(img);
      }

      const content = document.createElement('div');
      content.className = 'chip-content';

      const title = document.createElement('div');
      title.className = 'chip-title';
      title.innerHTML = formatTitleWithParens(ev.title || '');
      content.appendChild(title);

      if (hasDesc) {
        const desc = document.createElement('div');
        desc.className = 'chip-desc';
        desc.innerHTML = markdownToHtml(ev.desc);
        content.appendChild(desc);
      }

      chip.appendChild(content);
      return chip;
    }


    /********************
     * Editor / Admin   *
     ********************/
    function enterEditMode() {
      state.editMode = true;
      document.getElementById('editor').classList.remove('hidden');
      document.getElementById('editor').setAttribute('aria-hidden', 'false');
      renderEditorFields();
    }
    function exitEditMode() {
      state.editMode = false;
      document.getElementById('editor').classList.add('hidden');
      document.getElementById('editor').setAttribute('aria-hidden', 'true');
      renderYearGrid();
    }

    function renderEditorUI() {
      // Static handlers within the editor
      document.getElementById('btn-exit-edit').onclick = exitEditMode;
      document.getElementById('btn-add-timeline').onclick = onAddTimeline;
      document.getElementById('btn-dup-timeline').onclick = onDupTimeline;
      makeConfirmable(
        document.getElementById('btn-del-timeline'),
        () => onDelTimeline(),
        { idleText: 'Delete Timeline', confirmText: 'Confirm' }
      );

      document.getElementById('btn-add-event').onclick = onAddEvent;

      // Import/Download are now here
      const fileImport = document.getElementById('file-import-editor');
      const btnDownload = document.getElementById('btn-download-editor');
      fileImport.onchange = onImportTimelinesJS;
      btnDownload.onclick = downloadTimelinesJS;
    }

    function renderEditorFields() {
      // Build the custom listbox instead of the native <select>
      renderTimelineList();

      // Default selection if none
      if (!state.selectedTimelineId && state.timelines.length) {
        state.selectedTimelineId = state.timelines[0].id;
        renderTimelineList();
      }

      // Render details for selected
      renderTimelineEditor();
    }


    function getSelectedTimeline() {
      return state.timelines.find(t => t.id === state.selectedTimelineId) || null;
    }

    function sortTimelineEvents(tl) {
      if (!tl || !Array.isArray(tl.events)) return;

      const safeYear = (ev) => {
        try {
          return { ok: true, year: parseYearToken(ev.year).year };
        } catch {
          return { ok: false, year: Number.POSITIVE_INFINITY };
        }
      };

      tl.events = tl.events
        .map((ev, idx) => ({ ev, idx }))
        .sort((A, B) => {
          const ay = safeYear(A.ev);
          const by = safeYear(B.ev);

          // 1) Year (invalid years sort last)
          if (ay.year !== by.year) return ay.year - by.year;

          // 2) Title (case-insensitive, empty titles last-ish)
          const at = String(A.ev.title || '').trim().toLowerCase();
          const bt = String(B.ev.title || '').trim().toLowerCase();

          if (at !== bt) return at.localeCompare(bt);

          // 3) Stable fallback to original order
          return A.idx - B.idx;
        })
        .map(x => x.ev);
    }


    function renderTimelineEditor() {
      const tl = getSelectedTimeline();

      const titleEl = document.getElementById('tl-title');
      const yearEl  = document.getElementById('tl-year');
      const descEl  = document.getElementById('tl-desc');
      const imageEl = document.getElementById('tl-image');

      const colorEl = document.getElementById('tl-color');
      const tbody = document.getElementById('events-body');
      const sortBtn = document.getElementById('btn-sort-events');

      if (sortBtn) {
        sortBtn.disabled = !tl;
        sortBtn.onclick = () => {
          if (!tl) return;
          sortTimelineEvents(tl);
          renderTimelineEditor();
          renderYearGrid();
        };
      }

      if (!tl) {
        titleEl.value = '';
        if (yearEl) yearEl.value = '';
        if (descEl) descEl.value = '';
        if (imageEl) imageEl.value = '';
        colorEl.value = '#cccccc';
        tbody.innerHTML = '<tr><td colspan="5" class="muted">No timeline selected</td></tr>';
        return;
      }

      // Ensure fields exist (backwards compatible)
      tl.year = (tl.year === undefined || tl.year === null || String(tl.year).trim() === '')
        ? '2000'
        : String(tl.year).trim();
      tl.description = String(tl.description || '');
      tl.image = String(tl.image || '');

      titleEl.value = tl.title || '';
      if (yearEl)  yearEl.value = String(tl.year);
      if (descEl)  descEl.value = tl.description;
      if (imageEl) imageEl.value = tl.image;
      colorEl.value = tl.color || '#cccccc';

      titleEl.oninput = debounce(() => {
        tl.title = titleEl.value.trim();
        renderTimelineList();
        renderToggleBar();
        renderYearGrid();
      }, 150);

      if (yearEl) {
        yearEl.oninput = debounce(() => {
          tl.year = yearEl.value.trim();
          renderYearGrid();
        }, 150);
      }

      if (descEl) {
        descEl.oninput = debounce(() => {
          tl.description = descEl.value;
          renderYearGrid();
        }, 150);
      }

      if (imageEl) {
        imageEl.oninput = debounce(() => {
          tl.image = imageEl.value.trim();
          renderYearGrid();
        }, 150);
      }

      colorEl.oninput = debounce(() => {
        tl.color = colorEl.value;
        renderTimelineList();
        renderToggleBar();
        renderYearGrid();
      }, 150);

      // --- Events table (unchanged from your current code) ---
      tbody.innerHTML = '';
      for (let i = 0; i < tl.events.length; i++) {
        const ev = tl.events[i];

        const tr = document.createElement('tr');

        // Year
        const tdYear = document.createElement('td');
        const inYear = document.createElement('input');
        inYear.type = 'text';
        inYear.placeholder = '1994 | 3000000bc | 20ya';
        inYear.value = ev.year || '';
        inYear.oninput = debounce(() => {
          ev.year = inYear.value.trim();
          try {
            // IMPORTANT: validate against this timeline's anchor year
            const ctx = { timelines: state.timelines, cache: new Map(), stack: [] };
            const anchorYear = resolveTimelineAnchorYear(tl, ctx);

            parseYearToken(ev.year, anchorYear, ctx);
            inYear.classList.remove('invalid');
            renderYearGrid();
          } catch {
            inYear.classList.add('invalid');
          }
        }, 150);
        tdYear.appendChild(inYear);

        // Title
        const tdTitle = document.createElement('td');
        const inTitle = document.createElement('input');
        inTitle.type = 'text';
        inTitle.placeholder = 'Event title (optional)';
        inTitle.value = ev.title || '';
        inTitle.oninput = debounce(() => {
          ev.title = inTitle.value.trim();
          renderYearGrid();
        }, 150);
        tdTitle.appendChild(inTitle);

        // Desc
        const tdDesc = document.createElement('td');
        const inDesc = document.createElement('textarea');
        inDesc.placeholder = 'Description (Markdown supported)';
        inDesc.value = ev.desc || '';
        inDesc.rows = Math.max(3, Math.min(10, (inDesc.value.split('\n').length || 1)));
        inDesc.style.width = '300px';
        inDesc.addEventListener('input', () => {
          inDesc.style.height = 'auto';
          inDesc.style.height = (inDesc.scrollHeight) + 'px';
        });
        inDesc.oninput = debounce(() => {
          ev.desc = inDesc.value;
          renderYearGrid();
        }, 150);
        requestAnimationFrame(() => {
          inDesc.style.height = 'auto';
          inDesc.style.height = (inDesc.scrollHeight) + 'px';
        });
        tdDesc.appendChild(inDesc);

        // Image
        const tdImg = document.createElement('td');
        const wrap = document.createElement('div');
        wrap.className = 'img-cell';

        const inImg = document.createElement('input');
        inImg.type = 'text';
        inImg.placeholder = 'slug.webp | book/slug.webp | https://…';
        inImg.value = ev.image || '';
        inImg.oninput = debounce(() => {
          ev.image = inImg.value.trim();
          imgPreview.src = resolveImageSrc(ev.image);
          renderYearGrid();
        }, 150);

        const imgPreview = document.createElement('img');
        imgPreview.className = 'img-preview';
        imgPreview.loading = 'lazy';
        imgPreview.alt = 'preview';
        imgPreview.src = resolveImageSrc(ev.image);

        wrap.appendChild(inImg);
        wrap.appendChild(imgPreview);
        tdImg.appendChild(wrap);

        // Delete
        const tdDel = document.createElement('td');
        const btnDel = document.createElement('button');
        btnDel.className = 'btn danger';
        btnDel.textContent = 'Delete';
        makeConfirmable(btnDel, () => {
          tl.events.splice(i, 1);
          renderTimelineEditor();
          renderYearGrid();
        }, { idleText: 'Delete', confirmText: 'Confirm' });
        tdDel.appendChild(btnDel);

        tr.appendChild(tdYear);
        tr.appendChild(tdTitle);
        tr.appendChild(tdDesc);
        tr.appendChild(tdImg);
        tr.appendChild(tdDel);
        tbody.appendChild(tr);
      }

      if (!tl.events.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 5;
        td.className = 'muted';
        td.textContent = 'No events yet.';
        tr.appendChild(td);
        tbody.appendChild(tr);
      }
    }

    function onAddTimeline() {
      const id = 'tl_' + Math.random().toString(36).slice(2, 8);
      const tl = { id, title: 'New Timeline', color: '#8aa', year: 2000, description: '', image: '', events: [] };
      state.timelines.push(tl);
      state.selectedTimelineId = id;
      renderTimelineList();     // NEW
      renderToggleBar();
      renderYearGrid();
      renderTimelineEditor();
    }
    function onDupTimeline() {
      const tl = getSelectedTimeline();
      if (!tl) return;
      const copy = JSON.parse(JSON.stringify(tl));
      copy.id = 'tl_' + Math.random().toString(36).slice(2, 8);
      copy.title = (tl.title || '(Untitled)') + ' (copy)';
      state.timelines.push(copy);
      state.selectedTimelineId = copy.id;
      renderTimelineList();     // NEW
      renderToggleBar();
      renderYearGrid();
      renderTimelineEditor();
    }
    function onDelTimeline() {
      const tl = getSelectedTimeline();
      if (!tl) return;
      const idx = state.timelines.findIndex(t => t.id === tl.id);
      if (idx >= 0) state.timelines.splice(idx, 1);
      state.selectedTimelineId = state.timelines[0]?.id || null;
      renderTimelineList();     // NEW
      renderToggleBar();
      renderYearGrid();
      renderTimelineEditor();
    }
    function onAddEvent() {
      const tl = getSelectedTimeline();
      if (!tl) return;
      tl.events.push({ year: '1994', title: '', desc: '', image: '' });
      renderTimelineEditor();
      renderYearGrid();
    }

    const debounce = (fn, ms = 200) => {
      let t = null;
      return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
    };

    /**********************
     * Import / Download  *
     **********************/
    async function onImportTimelinesJS(evt) {
      const file = evt.target.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        // For local file use, we just eval into window.TIMELINES_DEFAULT safely via a Blob
        const blobUrl = URL.createObjectURL(new Blob([text], { type: 'text/javascript' }));
        const el = document.createElement('script');
        el.src = blobUrl;
        el.onload = () => {
          URL.revokeObjectURL(blobUrl);
          state.timelines = normalizeTimelines(window.TIMELINES_DEFAULT?.timelines);
          state.selectedTimelineId = state.timelines[0]?.id || null;
          renderEditorFields();
          renderToggleBar();
          renderYearGrid();
        };
        el.onerror = (e) => {
          URL.revokeObjectURL(blobUrl);
          alert('Import failed.');
          console.error(e);
        };
        document.head.appendChild(el);
      } catch (err) {
        alert('Import failed: ' + err.message);
        console.error(err);
      } finally {
        evt.target.value = '';
      }
    }

    function downloadTimelinesJS() {
      const code = generateTimelinesModule(state.timelines);
      const blob = new Blob([code], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'timelines.js';
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(url);
      a.remove();
    }

    function generateTimelinesModule(timelines) {
      const safe = JSON.stringify(timelines, null, 2);
      return `// Generated by Year Timelines\nwindow.TIMELINES_DEFAULT = {\n  timelines: ${safe}\n};\n`;
    }

    function normalizeTimelines(arr) {
      const timelines = Array.isArray(arr) ? arr : [];

      for (const tl of timelines) {
        tl.id ||= 'tl_' + Math.random().toString(36).slice(2, 8);
        tl.title ||= '(Untitled)';
        tl.color ||= '#8aa';

        tl.description = String(tl.description || '');
        tl.image = String(tl.image || '');

        // IMPORTANT: keep year as a token string
        // Accept numbers by converting to string, but don't coerce expressions to 2000.
        if (tl.year === undefined || tl.year === null || String(tl.year).trim() === '') {
          tl.year = '2000';
        } else {
          tl.year = String(tl.year).trim();
        }

        tl.events = Array.isArray(tl.events) ? tl.events : [];
        for (const ev of tl.events) {
          ev.year = String(ev.year || '').trim();
          ev.title = String(ev.title || '');
          ev.desc = String(ev.desc || '');
          ev.image = String(ev.image || '');
        }
      }

      return timelines;
    }



    /************
     * Boot     *
     ************/
    function initState(initialModule) {
      state.timelines = normalizeTimelines(initialModule?.timelines);
      state.selectedTimelineId = state.timelines[0]?.id || null;
      state.theme = 'light';
    }
    initState(DATA_DEFAULT);
    renderApp();
  </script>
</body>

</html>